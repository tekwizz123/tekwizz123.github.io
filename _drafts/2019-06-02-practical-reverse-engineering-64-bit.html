---
layout: post
title: Practical Reverse Engineering - 64 Bit Questions
date: '2019-06-02T20:39:00.000-07:00'
author: thetekwizz
tags: 
modified_time: '2019-06-02T20:39:30.226-07:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-8350577887941761212
blogger_orig_url: https://tekwizz123.blogspot.com/2019/06/practical-reverse-engineering-64-bit.html
---

<h3>Question 1: Explain two methods to get the instruction pointer on x64. At least one of the methods must use RIP addressing.</h3>Method 1:<br /><br />\xEB\x00\x00\x00\x00&nbsp; ---&gt; CALL RIP+4<br />\x58 --------------------------&gt; POP RAX<br />\x83\xC0\x04 ---------------&gt; ADD RAX, 4<br /><br />Method 2 (Using RIP addressing):<br /><br />This was found after looking around at how RIP addressing was being used and noticing that I could reference [RIP] using a MOV instruction but that would simply get the data pointed to by RIP. Should have realized LEA is also valid. Credits go to <a href="http://www.codegurus.be/Programming/riprelativeaddressing_en.htm#Mode64">http://www.codegurus.be/Programming/riprelativeaddressing_en.htm#Mode64</a> for inspiration on this one. Also nice to note that this is 2 bytes shorter than the example shown above.<br /><br />\x48\x8D\x05\x00\x00\x00\x00 ---&gt; LEA RAX, [RIP]<br /><br /><h3>Question 2: Perform a virtual-to-physical address translation on x64. Where there any major differences compared to x86?&nbsp;</h3>So one of the main differences between x64 and x86 is that with x64 we have a much larger address space. As a result one of the changes that was made to the virtual to physical address translation process was to add a new table, the Page Map Level 4 table, into the translation process. There are 512 page directory pointers inside the Page Map Level 4 table containing the physical addresses of each of the page directory tables. Note however that although there are 512 slots available the actual number of page directory tables in use will vary depending on the amount of physical memory available.<br /><br />A full explanation of how everything maps together is best seen on page 381 of Windows Internals 7th Edition, however as I don't have permission to repost their content I'm going to do my best to sum up what they show in the diagram on that page:<br /><br />Basically on x64 we have the following:<br /><br />CR3 ----&gt; Points now to the base address of the Page Map Level 4 table. Before on x86 it pointed to the base address of the Page Directory Pointer table.<br /><br />Bits 47 to 39 ---&gt; Points to the entry in the Page Map Level 4 table holding the physical address of the corresponding Page Directory Pointer table (remember in x86 there was only one of these tables).<br /><br />Bits 38 to 30 ---&gt; Points to the entry in the Page Directory Pointer table containing the physical address of the corresponding Page Directory table <br /><br />Bits 29 to 21 ---&gt; Points to the offset in the Page Directory table containing the physical address of the corresponding Page Table.<br /><br />Bits 20 to 12 ---&gt; Points to the Page in the Page Table that corresponds to the address.<br /><br />Bits 11 to 0 -----&gt; Points to the byte within the page corresponding to the virtual address.<br /><br /><br />So lets try an example. How about this:<br /><br />0: kd&gt; !process 0 0 notepad.exe<br />PROCESS ffff9087437d9080<br />&nbsp;&nbsp;&nbsp; SessionId: 1&nbsp; Cid: 1a94&nbsp;&nbsp;&nbsp; Peb: 3ad7747000&nbsp; ParentCid: 0e20<br />&nbsp;&nbsp;&nbsp; DirBase: 82357002&nbsp; ObjectTable: ffffdb0d60504080&nbsp; HandleCount: 229.<br />&nbsp;&nbsp;&nbsp; Image: notepad.exe<br /><br /><br /><br />0: kd&gt; r @cr3<br />cr3=00000000001aa002<br /><br />We'll take the address 3ad7747000 and try to translate it. Translating it to binary we get the following:<br /><br />‭‭000000000 011101011 010111011 101000111 000000000000‬<br /><br />aka:<br /><br />0x0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xEB &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xBB &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x147 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0<br /><br />The first instruction we need to be aware of is the !dq instruction which is like the normal 'dq' command your familiar with in WinDBG (dump memory as QWORDs), but it works on physical addresses.<br /><br />If we use the address of CR3, which points to the physical address of the Page Map Level 4 table, and the take into account that that address is using entry 0, or the first entry, within the page map table, and examine the value at that address, we should get the following:<br /><br />0: kd&gt; !dq 00000000001aa002+0*8 L1<br />#&nbsp; 1aa000 8a000001`03d93867<br /><br />So from here we can tell that the address of the Page Directory Pointer table corresponding to our address is at the physical address 0x8a000001`03d93867. We also know that our address is using entry number 0xEB within this table. So lets once again perform the same actions to find the physical address of the Page Directory for our address:<br /><br /><br /><br /><br /><br /><br /><br /><br />