---
layout: post
title: 'Practical Reverse Engineering - Chapter 1 pg 35 - Exercise #4'
date: '2018-12-06T21:51:00.000-08:00'
author: thetekwizz
tags: 
modified_time: '2018-12-10T19:50:40.978-08:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-3168246422714345408
blogger_orig_url: https://tekwizz123.blogspot.com/2018/12/practical-reverse-engineering-chapter-1.html
---

Question: Implement the following functions in x86 assembly: <i>strlen</i>, <i>strchr</i>, <i>memcpy</i>, <i>memset</i>, <i>strcmp</i>, <i>strset</i>.<br /><br /><u>strlen</u><br /><pre><code class="x86asm">push ebp<br />mov ebp, esp<br />push edi; Save nonvolatile register.<br />push esi; Save nonvolatile register.<br />mov edi, [ebp+0x8]; Set ESI to the first argument passed in <br />                  ; aka the pointer to the string.<br />mov esi, edi; Save original starting point of the string into ESI.<br />xor al, al; Set AL or the byte being searched for, <br />          ; to 0, or a NULL byte.<br />repne scasb; Keep incrementing EDI and comparing it to see <br />           ; if it is a NULL byte. Stop loop when a NULL <br />           ; byte is hit.<br />sub edi, esi; EDI will contain the address of a NULL byte. Subtract<br />            ; this address by ESI or the address of the start of the<br />            ; string to find the number of bytes read aka the string <br />            ; length and save this number in EDI.<br />mov eax, edi; Return EDI or the string length.<br />pop esi; Restore original ESI value.<br />pop edi; Restore original EDI value.<br />mov esp, ebp; Restore ESP value<br />pop ebp; Restore frame pointer value<br />ret; Return<br /></code></pre><br /><u>strchr</u><br /><pre><code class="x86asm">push ebp<br />mov ebp, esp; Save ESP value for later restoration. Part of function prologue.<br />push ebx ; EBX is not a volatile register, so save it onto <br />         ; the stack for later restoration. EAX, ECX, and <br />         ; EDX are volatile (https://en.wikibooks.org/wiki/X86_Assembly/High-Level_Languages#STDCALL)<br />mov edx, [ebp+0xC] ; Set EDX to the value of the second <br />                   ; argument aka <i>int character</i><br />mov ebx, [ebp+0x8] ; Set EBX to the value of the first<br />                   ; argument aka <i>char * str</i><br />check_null:<br />    mov ecx, byte ptr [ebx]; Perform a memory read to get the value<br />                           ; of the current byte in the string.<br />                           ; Doing this at the top of the loop saves<br />                           ; us having to do extra memory reads.<br />    cmp ecx, 0 ; Check that we haven't reached the end of the <br />               ; string aka the NULL byte.<br />    mov  eax, 0 ; Prepare to return 0, aka a <br />                ; NULL pointer, as the result.<br />    jz finish ; Jump to finish if the current byte in the string <br />              ; is NULL, aka we hit the end of the string.<br />check_equal:<br />    cmp ecx, edx ; Check if current character in string<br />                 ; is the one being searched for.<br />    mov eax, ebx ; Set EAX to the location where the character was<br />                 ; found to set return value correctly.<br />    jz finish ; Jump to finish if the current byte in the<br />              ; string is the one being searched for.<br />loop_jump:<br />    inc ebx ; Increment EBX to point to the <br />            ; next character in the string<br />    jmp check_null ; Jump back to the top of the loop to<br />                   ; continue searching through the string.<br />finish:<br />    pop ebx ; Restore EBX back to its original value.<br />    mov esp, ebp ; Restore ESP back to its original value.<br />    pop ebp ; Set EBP or the frame pointer, back to its previous value.<br />    ret ; Return<br /></code></pre><br /><u>memcpy</u><br /><pre><code class="x86asm">push ebp<br />mov ebp, esp ; Function prologue<br />push esi ; Save original ESI value, nonvolatile register.<br />push edi ; Save original EDI value, nonvolatile register.<br />mov ecx, [ebp+0x10] ; Set ECX to <b>size</b> or the number of bytes to copy over.<br />mov esi, [ebp+0xC] ; Set ESI to the value of the <b>source</b> argument.<br />mov edi, [ebp+0x8] ; Set EDI to the value of the <b>destination</b> argument.<br />cld ; Thanks to zerosum0x0 for pointing out in his articles that <br />    ; this needs to be done. Otherwise we can't be sure that EDI <br />    ; and ESI will be incremented when doing movsb operation.<br />rep movsb ; Move ECX number of bytes from ESI, or <b>source</b> to <br />          ; EDI, or <b>destination</b>, incrementing EDI and ESI<br />          ; with each byte read.<br />mov eax, [ebp+0x8] ; Set EAX, or the return value, to <b>destination</b>.<br />pop edi ; Restore original EDI value.<br />pop esi ; Restore original ESI value.<br />mov esp, ebp<br />pop ebp ; Function epilogue<br />ret<br /></code></pre><br /><i><u>memset</u></i><br /><pre><code class="x86asm">push ebp<br />mov ebp, esp ; Function prologue<br />push edi ; Save value of EDI register, nonvolatile register.<br />mov ecx, [ebp+0x10] ; Set ECX to the argument <b>num</b> <br />                    ; or number of bytes to set.<br />mov eax, [ebp+0xC] ; Set EAX to the argument <b>value</b> or <br />                   ; the value to set the bytes to.<br />mov edi, [ebp+0x8] ; Set EDI to the argument ptr or the <br />                   ; address of the block of memory to fill.<br />cld ; Set the direction flag to 0 to ensure EDI is incremented<br />    ; every time the stosb instruction is executed.<br />rep stosb ; Fill ECX bytes of memory with the value in EAX,<br />          ; starting at the address in EDI. EDI will be <br />          ; incremented each time the stosb instruction is executed.<br />mov eax, [ebp+0x8] ; Set the return value to the start of the<br />                   ; block of memory that was filled out.<br />pop edi ; Set EDI back to its original value.<br />mov esp ebp<br />pop ebp ; Function epilogue<br />ret;<br /></code></pre><br /><i><u>strset</u></i><br /><pre><code class="x86asm">push ebp ; Save previous frame pointer onto the stack.<br />mov ebp, esp ; Set EBP to point to the current frame pointer.<br />mov eax, [ebp+0xC] ; Set EAX to the argument int c<br />mov ecx, [ebp+0x8]; Set ECX to the argument char * str<br />loop_start:<br />   cmp byte ptr [ecx], 0 ; Check if the current byte of the <br />                         ; string being processed is NULL.<br />   jz finish ; Jump to the finish if it is.<br />   mov byte ptr [ecx], al ; Set the current byte in the string<br />                          ; to the value of the argument c.<br />   inc ecx ; Set ECX to point to the next byte in the string.<br />   jmp loop_start ; Jump back to the start of the loop.<br />finish:<br />  mov eax, [ebp+8] ; Set the return value to the address of <br />                   ; the first byte of the string that was set.<br />  mov esp, ebp ; Restore previous ESP value<br />  pop ebp ; Restore previous stack frame value.<br />  ret<br /></code></pre><br /><i><u>strcmp</u></i><pre><br /><code class="x86asm">push ebp<br />mov ebp, esp ; Function prologue code<br />push edi ; Save EDI value, nonvolatile register.<br />push esi ; Save ESI value, nonvolatile register.<br />mov edx, [ebp+0xC] ; Set EDX to str2<br />mov ecx, [ebp+0x8] ; Set ECX to str1<br />dec edx ; Subtract EDX by 1 since the later loop_start code will be <br />        ; incrementing it by 1 for each iteration of the loop.<br />dec ecx ; Subtract ECX by 1 since the later loop_start code will be <br />        ; incrementing it by 1 for each iteration of the loop.<br />loop_start:<br />    inc edx ; Increment EDX to point to the next byte in the str2 string.<br />    inc ecx ; Increment ECX to point to the next byte in the str1 string.<br />    mov edi, byte ptr [edx] ; Set EDI to current byte in str2 being processed.<br />    mov esi, byte ptr [ecx] ; Set ECX to current byte in str1 being processed.<br />    cmp esi, edi ; Compare current byte in str1 to current byte in str2.<br />    jl lower_str1 ; If the value of the current byte being processed <br />                  ; in str1 is lower than the value of the current <br />                  ; byte being processed in str2, then jump to lower_str1.<br />    jg greater_str1 ; If the value of the current byte being processed <br />                  ; in str1 is greater than the value of the current <br />                  ; byte being processed in str2, then jump to greater_str1.<br />    jmp compare_null ; If the current byte being processed in str1 is <br />                     ; equal to the current byte being processed in str2,<br />                     ; then jump to compare_null to see if we the byte <br />                     ; that was compared is a NULL byte aka we have <br />                     ; reached the end of both strings.<br />lower_str1:<br />    mov eax, -1 ; If the first character that does not match has a lower<br />                ; value in str1 than str2, return a value < 0. The value<br />                ; -1 will work for our purposes.<br />    jmp finish ; Jump to cleanup code.<br />greater_str1:<br />    mov eax, 1 ; If the first character that does not match has a <br />               ; greater value in str1 than str2, return a value<br />               ; > 0. The value 1 will work for our purposes.<br />    jmp finish ; Jump to cleanup code.<br />compare_null:<br />    test edi, edi ; Check that the bytes being currently being processed <br />                  ; in str1 and str2, which have been determined to be <br />                  ; the same as one another, are not NULL bytes.<br />    jnz loop_start ; If the bytes that were matched are not NULL <br />                   ; bytes, continue the processing loop.<br />    mov eax, 0 ; Otherwise if they are both NULL bytes, set the<br />               ; return value to 0 to indicate the two strings <br />               ; are the same as one another.<br />finish:<br />    pop esi ; Restore the original value of ESI.<br />    pop edi ; Restore the original value of EDI.<br />    mov esp, ebp<br />    pop ebp ; Function epilogue code<br />    ret<br /></pre></code>