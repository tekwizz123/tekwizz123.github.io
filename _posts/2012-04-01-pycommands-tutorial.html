---
layout: post
title: PyCommands Tutorial
date: '2012-04-01T07:53:00.002-07:00'
author: thetekwizz
tags:
- PyCommand
modified_time: '2012-06-01T19:40:37.644-07:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-6022184209783547346
blogger_orig_url: https://tekwizz123.blogspot.com/2012/04/pycommands-tutorial.html
---

Hey guys so I have been playing around a lot with the Grey Hat Python book and just been walking through the book chapter by chapter so I thought I might share some of the stuff that I have learned so that a) it stays in my mind and b) you guys can also learn more.<br /><br />Without futher ado, lets start!<br /><br /><br /><u>Enter Immunity Debugger</u><br />Okay before I start I would like to provide a very brief intro into what I'm about to cover for those of you who might not know what PyCommands are.<br /><br />Essentially PyCommands are commands (or more specifically, Python scripts) that you can run from within Immunity Debugger that allow you to essentially control various parts of the debugger while it is running. This essentially means that Immunity Debugger is what is known as a "scriptable debugger", and if you don't know what that means, please use your good friend Google who will kindly tell you a much better answer than I can provide here :)<br /><br /><u>Getting Started</u><br /><u><br /></u><br />Okay first off we are going to need to get Immunity Debugger, which can be downloaded from here:<br /><br /><a href="http://debugger.immunityinc.com/register.html">http://debugger.immunityinc.com/register.html</a><br /><br />Please note that the registration info is not needed. In fact you can just click next and continue on.<br /><br />Next, take a look at the API help guide. While its not much it will help you to make future programs so go ahead and take a look though what functions Immunity Debugger provides for you. It might not make sense right now, but it will give you an idea of the power that is involved.<br /><br />Access it by doing the following:<br /><br />1. Open up Immunity Debugger<br />2. Go to Help, then select "Select API help file"<br />3. Go to the Documentation file under the Immunity Debugger installation file<br />4. Select IMMLIB.HLP<br /><br />Also you can take a look at the online documentation located at&nbsp;<a href="http://debugger.immunityinc.com/Documentation/">http://debugger.immunityinc.com/Documentation/</a>&nbsp;(this address is new, some old books may reference a different address but this is the one that works atm)<br /><br /><br /><u>Running A PyCommand</u><br /><br />To run a command, make sure that it is in you PyCommands folder in Immunity Debugger and then find that white box at the bottom and enter:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; !(name of the script goes here) (arg1) (futher arguments)<br /><br />And then once done, check the Log window (if you don't know where that is, then just go to View and then select Log)<br /><br />Also please note that all of the scripts that we will be viewing/writing today are based on Python 2.x, not Python 3.x. Make sure you remember that as there are slight differences between the two, and thus this might affect your results. Just saying...feel free to use 3.x if you REALLY want to (hehe).<br /><br /><br /><u>Basic Structure of A PyCommand Script</u><br />Okay what follows is what you need at a minimal outline to create PyCommand script:<br /><br />*enter code mode*<br /><br />#!/usr/bin/env python<br /><br />from immlib import *<br /><br />def main(args):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Instantiate a immlib.Debugger instance of the current debugger process that is running right now.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imm = Debugger()<br /><br />&nbsp; &nbsp; &nbsp; &nbsp;*Any commands would go here at this point. Sorry about formatting as Blogger is a bi**h with code ;)*<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# This command is not required, its only so that the command returns input to the user so that they &nbsp; &nbsp; &nbsp;know that the script is done (this is displayed below the white box where you enter the commands)<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; return "[*] PyCommand Executed!"<br /><br /><br />* End code mode*<br /><br /><br /><u>A Couple of Simple Commands + Bits of Information</u><br /><u><br /></u><br /><br /><ul><li><b>imm.log</b>("String goes here %d" % a number in this case, *if you want, instead of the code displaying 0xBADF00D, it will display the memory address you place here (note that the decimal value you place here will be converted into a hex value*)</li><ul><li>This writes the given message to Immunity Debuggers logs (which can be viewed via View-&gt; Logs). If an address is specified, then that is used in place of the address 0xBADF00D.</li></ul><li><b>imm.updateLog</b>()</li><ul><li>Normally when a script runs, the log will only be updated after the script has finished running. If you want the logs to update at a certain spot instead of waiting till the end, then place this after your calls to imm.log() to have Immunity's logs update&nbsp;themselves&nbsp;right then and there. Useful if you doing CPU intensive processes and you want to notify the user of what's going on, however note that this will cause the process to take a bit longer to run than if you didn't use the updateLog() call.</li></ul><li><b>imm.createTable</b>('Name', ['name of column one', 'name of column two', 'and so on'])</li><ul><li>Creates a table with the name (in this case <i>Name</i>) and then adds the columns with their given names to the table</li></ul><li><b>table.add</b>(0 , ["column one's value", "column two's value", "etc"])</li><ul><li>Pretty self explanatory, 0 is just the number (starting from 0) of the table</li></ul><li><b>imm.assemble</b>(*insert your variable here*)</li><ul><li>Transforms you variable into assembly code.</li></ul><li><b>imm.search</b>(*insert variable here*)</li><ul><li>Searches all of the memory in the current process for your selected variable (which must be in assembly code mind you) and returns a list of addresses where it found that variable in memory.</li></ul><li><b>imm.readMemory</b>(address, size)</li><ul><li>Read <i>size</i> bytes from the address located in <i>address </i>and return them.</li></ul><li><b>imm.writeMemory</b>(address, buf)</li><ul><li>Write the assembly buffer <i>buf</i>&nbsp;into the address located at <i>address</i></li></ul><li><b>imm.ps()</b></li><ul><li>List all the running processes and return (according to the docs) a "<span style="background-color: #e8f0f8;">list of tuples with process information (pid, name, path, services, tcp list, udp list)"</span></li></ul><li><b>imm.searchCommands(cmd)</b></li><ul><li>Search in all loaded executables for a given command (the command must be given as a string) with newlines represented by "\n" (minus quotes)</li></ul><li><b>imm.getRegs</b>()</li><ul><li>Returns a Dictionary of all of the x86 registers</li></ul><li><b>imm.setRegs</b>(reg, value)</li><ul><li>Sets the register represented by the string <i>reg</i>&nbsp;to the DWORD value <i>value</i>.</li></ul><li><b>imm.getPEB</b>()</li><ul><li>Get the PEB of the current process.</li></ul><li><b>imm.getPEBaddress</b>():</li><ul><li>Returns the DWORD address of the current process's PEB.</li></ul><li><b>imm.getAddress</b>(expression)</li><ul><li>Gets the address of expression (which is a string)</li><li>Ex: imm.getAddress("kernel32.Process32FirstW") -&gt; returns the address of Process32FirstW which is used to&nbsp;iterate&nbsp;though&nbsp;available&nbsp;processes currently running on the system in case your interested ;)</li></ul></ul><div>Okay that should be enough for you to get most scripts done. <b>If you need to write to a file at any time, the process is the same as you would do in a normal python script.</b></div><div><b><br /></b></div><div><u>Some Example Scripts From Grey Hat Python</u></div><div><u><br /></u></div><div>Again I claim no credit for these. They are all the work of Justin Setiz and all credit goes to him for creating these except for one which I will mention shortly.</div><div><br /></div><div><u>badchar,py</u></div><div><u><br /></u></div><div><u><br /></u></div><div>*BEGIN CODE SEGMENT*</div><div><u><br /></u></div><div><div>from immlib import *</div><div><br /></div><div>def main(args):</div><div><br /></div><div>&nbsp; &nbsp; imm = Debugger()</div><div><br /></div><div>&nbsp; &nbsp; bad_char_found = False</div><div><br /></div><div>&nbsp; &nbsp; # First argument is the address to begin our search</div><div>&nbsp; &nbsp; address = int(args[0],16)</div><div><br /></div><div>&nbsp; &nbsp; # Shellcode to verify</div><div>&nbsp; &nbsp; shellcode = "&lt;INSERT SHELLCODE HERE&gt;"</div><div>&nbsp; &nbsp; shellcode_length = len(shellcode)</div><div><br /></div><div>&nbsp; &nbsp; debug_shellcode = imm.readMemory( address, shellcode_length )</div><div>&nbsp; &nbsp; debug_shellcode = debug_shellcode.encode("HEX") # We need to encode the debug_shellcode from assembly into hex format so that we can compare it to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # the shellcode we inserted just above here.</div><div><br /></div><div>&nbsp; &nbsp; imm.log("***************************************")</div><div><br /></div><div>&nbsp; &nbsp; imm.log("Address: 0x%08x" % address)</div><div>&nbsp; &nbsp; imm.log("Shellcode Length: %d" % shellcode_length)</div><div><br /></div><div><br /></div><div>&nbsp; &nbsp; #Begin a byte by byte comparison of the two shellcode buffers</div><div>&nbsp; &nbsp; count = 0</div><div>&nbsp; &nbsp; while count &lt; shellcode_length:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if debug_shellcode[count] != shellcode[count]:</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imm.log("Bad Char Detected at offset %d" % count)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bad_char_found = True</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; &nbsp; count += 1</div><div><br /></div><div>&nbsp; &nbsp; if bad_char_found:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("[*****]")</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("Bad char found %s" % debug_shellcode[count])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("Expected to find: %s" % shellcode[count])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("[*****]")</div><div style="text-decoration: underline;"><br /></div><div>&nbsp; &nbsp; else:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("[*****]")</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("No bad characters found :) Your good to go!")</div><div>&nbsp; &nbsp; &nbsp; &nbsp; imm.log("[*****]") &nbsp; &nbsp; &nbsp; &nbsp;</div><div><br /></div><div>&nbsp; &nbsp; return "[*] !badchar finished, check Log window."</div><div><br /></div><div>*END CODE SEGMENT* </div><div><br /></div><div><u>Defeat IsDebuggerPresent (for use against malware)</u></div><div><u><br /></u></div><div>This is the only piece of code that is mine. The creator of this technique was Damian Gomez of Immunity.</div><div><u><br /></u></div><div>*BEGIN CODE SEGMENT*</div><div><br /></div><div><div>from immlib import *</div><div><br /></div><div>def main(args):</div><div>&nbsp; &nbsp; imm = Debugger()</div><div><br /></div><div><br /></div><div>&nbsp; &nbsp; # This is the initial test to see what it was before:</div><div><br /></div><div>&nbsp; &nbsp; result = imm.readMemory( imm.getPEBAddress() + 0x2, 1 )</div><div><br /></div><div>&nbsp; &nbsp; # At PEB + 0x2 in a process is the BeingDebugged variable which is what</div><div>&nbsp; &nbsp; # the function IsBeingDebugged returns. If we set this to 0 then</div><div>&nbsp; &nbsp; # IsBeingDebugged is tricked into thinking that the process is not being</div><div>&nbsp; &nbsp; # debugged because hey, thats what the process is reporting right?</div><div>&nbsp; &nbsp; # And thats one of many ways to get around anti-debugging techniques.</div><div><br /></div><div>&nbsp; &nbsp; result = result.encode("HEX")</div><div><br /></div><div>&nbsp; &nbsp; imm.log("Before the change: %s" % result)</div><div><br /></div><div><br /></div><div>&nbsp; &nbsp; #Make the change</div><div><br /></div><div>&nbsp; &nbsp; imm.writeMemory( imm.getPEBAddress() + 0x2, "\x00" )</div><div><br /></div><div><br /></div><div>&nbsp; &nbsp; # And print the new results</div><div><br /></div><div>&nbsp; &nbsp; result = imm.readMemory( imm.getPEBAddress() + 0x2, 1 )</div><div><br /></div><div>&nbsp; &nbsp; result = result.encode("HEX")</div><div><br /></div><div>&nbsp; &nbsp; imm.log("Result after change: %s" % result)</div><div><br /></div><div>&nbsp; &nbsp; return "!defeatDebuggerPresent is done."</div><div><br /></div><div><br /></div></div><div>*END CODE SEGMENT*</div><div><br /></div><div><br /></div><div><u>findantidep.py</u></div><div><u><br /></u></div><div>Included by default in Immunity Debugger. This is a GUI program that takes you through the process of disabling DEP on a specific process you are debugging and then returning execution to the area of code your &nbsp;shellcode is in. I will let you figure out how to use this because your&nbsp;probably&nbsp;smart enough to figure it out yourself if you have a need to use it (and space. may make&nbsp;separate&nbsp;tutorial on it as its an entire tutorial in itself to be honest)</div><div><br /></div><div><u>End</u></div><div><u><br /></u></div><div>Thats all fokes. Hopefully you can continue to use the examples given above in combination with the API guide to create some&nbsp;awesome&nbsp;scripts. And if you create something really awsome, let me know and if its good i'll post it up on here along with your name :)</div><div><br /></div><div>And im out mates</div><div><br /></div><div>-tekwizz123</div></div>