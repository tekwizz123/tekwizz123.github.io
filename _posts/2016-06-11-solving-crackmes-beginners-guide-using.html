---
layout: post
title: 'Solving Crackmes: A Beginner''s Guide Using LuCiFeR''s Crackme 2 and Hopper
  Disassembler'
date: '2016-06-11T12:32:00.000-07:00'
author: thetekwizz
tags: 
modified_time: '2016-06-11T12:32:25.208-07:00'
thumbnail: https://4.bp.blogspot.com/-4P-Dx2myrfU/V1sv3QFpxOI/AAAAAAAAAmo/wYfJARIyHZY8eeEkrvqVWysiTXJeZy76wCK4B/s72-c/LuCiFeR%2BCrackme%2BInitial%2BAnalysis.PNG
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-3529911307183590802
blogger_orig_url: https://tekwizz123.blogspot.com/2016/06/solving-crackmes-beginners-guide-using.html
---

<h3><span style="font-size: large;"><u>Intro</u></span></h3>So as some of you guys may know, I now work for NCC Group as a Security Consultant doing web and infrastructure pentesting. This normally means that I don't tend to do very much security work outside of that. Lately however, I have gotten the oppertunity to do some more research, specifically with reverse engineering. One afternoon I wanted to do something interesting, and remembered about the idea of crackme's, or small programs that people create to be reverse engineered.<br /><br />Crackme's usually have some sort of goal in mind. For example, they may ask you to find a working serial for the program, or to remove an annoying popup that appears every time the program starts. Additionally they may have some restrictions on a proper solution. For example they may also state that you can't patch the program's assembly so that it jumps over the function that displays the nag screen and that instead you must find another way to solve the problem.<br /><br />After looking around at a few crackme's I eventually found one that I thought would be a good, very easy challenge to start off with: LuCiFeR's Crackme #2. You can find the file at <a href="http://crackmes.de/users/lucifer/first_c_crackme/">http://crackmes.de/users/lucifer/first_c_crackme/</a>. Alternatively, you can download it here if you don't want to sign up for an account at crackmes.de: <a href="https://drive.google.com/file/d/0B5pT4hU_yYUWeXFvS2RLeDhoTWc/view">https://drive.google.com/file/d/0B5pT4hU_yYUWeXFvS2RLeDhoTWc/view</a><br /><h3><br /></h3><h3><span style="font-size: large;"><u>Tools Used </u></span></h3>To solve this crackme, I originally used OllyDBG and BinaryNinja. That being said however, BinaryNinja is currently in beta and after testing it for a while I found I really don't like it's limitations, such as not being able to search for cross references to a string. Because of that, for this tutorial I will be using Hopper Disassembler. You can use the demo version or the paid version for this tutorial, though I will be using the paid version as I have a personal license. To download Hopper Disassembler, simply visit&nbsp; as well if you want, which is available from <a href="http://hopperapp.com/download.html">http://hopperapp.com/download.html</a>.<br /><br />Keep in mind the demo version of the application has a 30 minute limitation on sessions and you cannot save your session. This is similar to the free version of IDA Pro with the exception that with IDA Pro's free version does not limit the session's length. If you don't want to pay the Â£70 for the full version of Hopper and you want longer sessions, but don't mind not being able to save your work, then you can also do this in IDA Pro's free version.<br /><h3><br /></h3><h3><span style="font-size: large;"><u>Initial Analysis</u></span></h3>To begin our analysis of the crackme, lets first read what the readme.txt file contains:<br /><ul><li>Rules:</li><li>1. Do not Patch</li><li>2. Sniff a serial for your name</li><li>3. write a keygen</li></ul>Okay, so looks like this is a serial crackme where we have to find the serial to make the program work. Additionally we have also been told that we cannot patch the program to disable any checks, and that we need to write a keygen. For those of you that are not aware, a keygen is a small program, written in whatever language you fancy, that will take in some input, such as a name, or some other input, and generate the correct corresponding output, such as a serial, for a given crackme.<br /><br />With that in mind, lets run the crackme and see what we have:<br /><br /><a href="http://4.bp.blogspot.com/-4P-Dx2myrfU/V1sv3QFpxOI/AAAAAAAAAmo/wYfJARIyHZY8eeEkrvqVWysiTXJeZy76wCK4B/s1600/LuCiFeR%2BCrackme%2BInitial%2BAnalysis.PNG" imageanchor="1"><img border="0" height="320" src="https://4.bp.blogspot.com/-4P-Dx2myrfU/V1sv3QFpxOI/AAAAAAAAAmo/wYfJARIyHZY8eeEkrvqVWysiTXJeZy76wCK4B/s640/LuCiFeR%2BCrackme%2BInitial%2BAnalysis.PNG" width="640" />&nbsp;</a><br /><br />Okay so we have a few things to note here. The first thing is that the program displays a menu. We should note this down as we may want to look through the program's strings in a disassembler and see if we can find any cross references to these strings in memory. This will then allow us to determine the corresponding function that prints the program's menu, which will help us start to analyse the program's execution flow.<br /><br />The other thing to note is that the program seems to be taking in a name and a serial as input. Based on the fact that the error message that is returned says that we have not entered the correct serial, it seems reasonable to make a guess that the program could be taking in the name as input into some sort of serial generation function. The serial that the user enters is then checked against the output from this function, and if the serials do not match, the program displays an error message and terminates.<br /><br />Now that we have done an initial analysis of the program and it's functionality, lets load it up into Hopper and examine it. Drag the executable into Hopper and accept the defaults to load it as a Windows PE file. Once Hopper has finished it's analysis, you should see something like the following:<br /><br /><a href="http://2.bp.blogspot.com/-rSMPsmuMzic/V1sx6W9zuOI/AAAAAAAAAm0/SqXMEb03PvEsR8fkUpOjB3O-wnK2q842gCK4B/s1600/Initial%2BHopper%2BView.PNG" imageanchor="1"><img border="0" height="405" src="https://2.bp.blogspot.com/-rSMPsmuMzic/V1sx6W9zuOI/AAAAAAAAAm0/SqXMEb03PvEsR8fkUpOjB3O-wnK2q842gCK4B/s640/Initial%2BHopper%2BView.PNG" width="640" />&nbsp;</a><br /><br />You may not be able to see it above, but Hopper has dumped us at the program's entry point, which it has helpfully denoted as the function EntryPoint. On the left we can see a whole bunch of functions, however none of them seem to have any helpful names.<br /><br />There's a few ways to solve this issue, but the way I like to do it is by looking at the program's strings. To do this, click on the button on the upper left next to the <i>Labels</i> button labeled <i>Strings</i>:<br /><br /><a href="http://3.bp.blogspot.com/-iYPixE5ssRU/V1szFNKRKzI/AAAAAAAAAnA/ryf96Uf4SBsU8zHhnepLZI29YiSfaUPygCK4B/s1600/Hopper%2BFinding%2BProgram%2BStrings.PNG" imageanchor="1"><img border="0" height="276" src="https://3.bp.blogspot.com/-iYPixE5ssRU/V1szFNKRKzI/AAAAAAAAAnA/ryf96Uf4SBsU8zHhnepLZI29YiSfaUPygCK4B/s640/Hopper%2BFinding%2BProgram%2BStrings.PNG" width="640" />&nbsp;</a><br /><br />Hey, would you look at that! There's several strings which appear to be from the program's menu. Lets see if we can find which function they are being used in. To do this, first double click on one of the strings that were printed within the menu. You should see something like the following:<br /><br /><a href="http://4.bp.blogspot.com/-0sPEXWEbZ28/V1szxbDpuCI/AAAAAAAAAnM/30KEJ0C61egTYvv_FKlS8AAH6fzr7rS7wCK4B/s1600/Hopper%2BListing%2BXREFS%2Bto%2Bmenu%2Bstrings.PNG" imageanchor="1"><img border="0" height="140" src="https://4.bp.blogspot.com/-0sPEXWEbZ28/V1szxbDpuCI/AAAAAAAAAnM/30KEJ0C61egTYvv_FKlS8AAH6fzr7rS7wCK4B/s640/Hopper%2BListing%2BXREFS%2Bto%2Bmenu%2Bstrings.PNG" width="640" /></a><br /><br />If you look to the left here, you can see hopper has helpfully provided several XREFs for each of the strings to let us know where they are being used. As you can see in the screenshot above, it seems like function sub_4014e2 is using all of these strings. Lets see if we can't examine this further. To examine the cross references for a particular string, single click on the string from the listing shown above (any one will do :) ), and then hit the <i>x </i>button on your keyboard:<br /><br /><a href="http://4.bp.blogspot.com/-Y_AhhUYTGcM/V1s2EARGL7I/AAAAAAAAAnY/CdfkSwAa4Ygu0xXpdB6p4eJAE2JDXLkQwCK4B/s1600/cross%2Breferences%2Bto%2Bmenu%2Bstring.PNG" imageanchor="1"><img border="0" height="378" src="https://4.bp.blogspot.com/-Y_AhhUYTGcM/V1s2EARGL7I/AAAAAAAAAnY/CdfkSwAa4Ygu0xXpdB6p4eJAE2JDXLkQwCK4B/s640/cross%2Breferences%2Bto%2Bmenu%2Bstring.PNG" width="640" />&nbsp;</a><br /><br />Ok, now in addition to the location of the cross reference, we can also see the specific instruction that references the particular string we chose to examine. To go to the corresponding function, simply hit the <i>Go To</i> button. This should give us the following:<br /><br /><a href="http://1.bp.blogspot.com/-zrPL4u9MoDQ/V1s2x9V0b9I/AAAAAAAAAnk/nZigipKeR8Y0QzFyrs50-FwloWaac-OvACK4B/s1600/dumped%2Binto%2Bmenu%2Bfunction.PNG" imageanchor="1"><img border="0" height="354" src="https://1.bp.blogspot.com/-zrPL4u9MoDQ/V1s2x9V0b9I/AAAAAAAAAnk/nZigipKeR8Y0QzFyrs50-FwloWaac-OvACK4B/s640/dumped%2Binto%2Bmenu%2Bfunction.PNG" width="640" /></a><br /><br />Looking at the assembly, we can see there are several strings which appear to be loaded into the variables <i>var_424</i> and <i>var_428</i> before the function <i>sub_431fe0</i> is called, presumably to print the string out to the screen. Lets rename these variables and the function to make it easier to read the disassembly.<br /><br />For starters, lets rename <i>sub_431fe0</i> to <i>print_buffer_to_screen.</i> To do this, click on the function <i>sub_431fe0 </i>within the disassembly, then hit the <i>n</i> button to rename the function:<br /><br /><a href="http://2.bp.blogspot.com/-fkkPOz_2NH4/V1s5ilv6qbI/AAAAAAAAAnw/tRyr6mrV1Qc8PoAxJEfkvKbA6pb1hQ1EgCK4B/s1600/rename%2Ba%2Bfunction.PNG" imageanchor="1"><img border="0" height="320" src="https://2.bp.blogspot.com/-fkkPOz_2NH4/V1s5ilv6qbI/AAAAAAAAAnw/tRyr6mrV1Qc8PoAxJEfkvKbA6pb1hQ1EgCK4B/s640/rename%2Ba%2Bfunction.PNG" width="640" />&nbsp;</a><br /><br />If we look at <i>sub_432880</i>, we notice that it seems to be being called every time that the program expects input. We can assume that this function grabs the user's input and saves it to a buffer, so lets rename this function to <i>grab_input_into_buffer</i>. When we are done we should get something like the following:<br /><br /><a href="http://2.bp.blogspot.com/-5vwaQBv1JVc/V1tCsMUkGHI/AAAAAAAAAoA/eEYMTbWDRCYzt3PLoM-v5dXn3zuPu1rXgCK4B/s1600/after%2Brenaming%2Bsome%2Bfunctions.PNG" imageanchor="1"><img border="0" height="128" src="https://2.bp.blogspot.com/-5vwaQBv1JVc/V1tCsMUkGHI/AAAAAAAAAoA/eEYMTbWDRCYzt3PLoM-v5dXn3zuPu1rXgCK4B/s640/after%2Brenaming%2Bsome%2Bfunctions.PNG" width="640" /></a><br /><br />The next thing we want to do is analyse what is being done with our input. To do this we need to focus on the calls to <i>grab_input_into_buffer</i>. Lets take a look at them:<br /><br /><a href="http://3.bp.blogspot.com/-D2SXnf0-ykI/V1tJx9JicPI/AAAAAAAAAoQ/cYQenaGcBLwUdHcNvjS_lrHORTaJn-SMACK4B/s1600/examining%2Binput%2Bcalls.PNG" imageanchor="1"><img border="0" height="224" src="https://3.bp.blogspot.com/-D2SXnf0-ykI/V1tJx9JicPI/AAAAAAAAAoQ/cYQenaGcBLwUdHcNvjS_lrHORTaJn-SMACK4B/s640/examining%2Binput%2Bcalls.PNG" width="640" />&nbsp;</a><br /><br />What we can see here is that EAX appears to be loaded with the location of a variable in memory (this is done via the LEA instruction). In the first call, this is <i>var_108</i>, whilst in the second call this is <i>var_208</i>. This address is then placed into <i>var_424</i>, which appears to serve as a pointer to the buffer in memory where our input should be stored. Following this we see that for both calls, <i>var_428</i> is passed the parameter 0x437510 prior to the call to <i>grab_input_to_buffer</i>. Combining this all together and using Hopper's helpful comments in green on the side, we can determine that <i>var_428</i> is the first argument to <i>grab_input_to_buffer</i>, which contains the stream number to grab the user's input from. The second parameter is <i>var_424</i>, which contains a pointer to the buffer in memory where the user's input is to be stored. This allows <i>grab_input_to_buffer</i> to effectively grab the user's input and store it in memory.<br /><br />Finally, if we look just after the second call to <i>grab_input_to_buffer</i>, we can see a call to <i>j_strlen</i> along with the parameter EAX, which appears to be loaded with the address of <i>var_108</i>, or the buffer where our name was stored earlier. Lets see what the program does once it has calculated the length of the name that we inputted into the program:<br /><br /><a href="http://1.bp.blogspot.com/-pWolnQzwx10/V1tPx4bgj-I/AAAAAAAAAog/V71h8_IE1-8G2WKeCgBxTRG94vcWXFR4ACK4B/s1600/calculating%2Binfo%2Bafter%2Bstrlen%2Bcall.PNG" imageanchor="1"><img border="0" height="332" src="https://1.bp.blogspot.com/-pWolnQzwx10/V1tPx4bgj-I/AAAAAAAAAog/V71h8_IE1-8G2WKeCgBxTRG94vcWXFR4ACK4B/s640/calculating%2Binfo%2Bafter%2Bstrlen%2Bcall.PNG" width="640" />&nbsp;</a><br /><br />First, the program loads the result of the strlen call from EAX into EDX at 0x00401676. We then go ahead and multiply EDX by 0x875cd, storing the result in EDX (the first parameter to IMUL is where to store the result, the second one is what to multiply 0x875cd by :)&nbsp; ). Once that is done, we move 0x51eb851f to EAX, and then execute <i>mul edx</i>.<br /><br />What is important to note at this point is that the <i>mul</i> instruction multiplies EAX by the parameter provided and stores the result in EDX:EAX. That is, the higher 32 bits of the result are stored in EDX, whilst the lower 32 bits of the result are stored in EAX.<br /><br />With this in mind, the next instruction, <i>MOV EAX, EDX</i> stores the higher 32 bits of the result into EAX. The instruction <i>SHR EAX, 0x5</i> then shifts EAX right 5, which is equivalent to dividing by 2 ^ 5, or 32.<br /><br />Once this is done we multiply the result by 0xfffffc90 and store it in EAX. Keep in mind that any result over 32 bits will be dropped at this point. In other words if we end up getting a 42 bit number as the result of the multiplication, the first 10 bits would be dropped and only the last 32 bits would be saved in EAX.<br /><br />Next we move 0x0 into EDX and push the values of EDX and EAX onto the stack. I do not know why this occurs as it does not impact anything and the values are not POP'd off the stack at any point.<br /><br />Following this, the instructions at 0x00401697 to 0x004016aa do some instructions with floating point numbers. We'll get into this with OllyDBG in a bit but for now just now that there is a seperate stack which is used for floating point numbers and these instructions use that stack to adjust our calculated serial somewhat.<br /><br />If we look at 0x004016ae to 0x004016bf we can see that we load the string <i>"%i-x019871"</i> into <i>var_42C</i> and the address of <i>var_308</i> into <i>var_430</i>. These are then used as the first and second arguments respectively for the call to <i>j_sprintf</i>, which seems to save the serial that we should have entered into <i>var_308</i>.<br /><br />Finally, we have a call to j_strcmp which compares two pointers to string buffers to see if their contents are the same or not. The first argument points to <i>var_208</i>, which holds the serial that we entered into the program. The second argument points to <i>var_308</i>, which holds the serial that we should have entered. The program then jumps to a goodboy or badboy message according to whether or not these two buffers matched or not.<br /><h3></h3><h3><br /></h3><h3><span style="font-size: large;"><u>Initial Overview of Crackme Algorithum</u></span></h3>At this point we can determine the algorithum works as follows:<br /><ol><li>The program calculates the length of the user's name.</li><li>This is then multiplied by 0x875cd.</li><li>The result of this operation is then multiplied by 0x51eb851f and the higher 32 bits of the result are saved.</li><li>Bit-shift this number right 5 bits, effectively dividing by 32.</li><li>Multiply this value by 0xfffffc90</li></ol>To figure out the final part of the algorithum (so we can generate a working solution) we need to turn to OllyDBG.<br /><h3><br /></h3><h3><span style="font-size: large;"><u>Using OllyDBG to Solve the Floating Point Instructions Issue</u></span></h3>With a understanding of most of the crackme's algorithum, we now turn to OllyDBG to understand the floating point instructions and how they change the final serial that is generated.<br /><br />To speed things up a bit, first set a breakpoint at the address 0x00401623, which is hit after the first part of the menu is printed out. If we scroll down we should see the same disassembly as in Hopper, with the first floating point instruction occuring at 0x00401697 after the <i>PUSH EDX</i> and <i>PUSH EAX</i> instructions. Let's put a breakpoint here so we can examine things further, and press F9 to continue the program. We enter in our name, and our serial, pressing F9 to continue the program as needed before eventually we hit the breakpoint:<br /><br /><a href="http://1.bp.blogspot.com/-gjCGVJkz-WQ/V1xO8f7FSAI/AAAAAAAAAow/k6cYszZ15vAIR_R6vlktSleNtC0dfsXngCK4B/s1600/breakpoint%2Bhit%2Bin%2Bollydbg.PNG" imageanchor="1"><img border="0" height="424" src="https://1.bp.blogspot.com/-gjCGVJkz-WQ/V1xO8f7FSAI/AAAAAAAAAow/k6cYszZ15vAIR_R6vlktSleNtC0dfsXngCK4B/s640/breakpoint%2Bhit%2Bin%2Bollydbg.PNG" width="640" />&nbsp;</a><br /><br />The next instruction, <i>FILD QWORD PTR SS:[ESP] </i>loads a QWORD, or a 64 bit number, from the location pointed at by ESP, and puts it onto the FPU (Floating Point Unit) stack. This can be seen in the following screenshot. Notice that ESP holds the value 0xFE8BC1A0 while ESP+4 holds the value 0x00000000. As we are reading a 64 bit value into the FPU stack, we read both of these values (a 32 bit, or DWORD read would just read the value at ESP, 16 bit, or WORD read, the SP register, etc etc):<br /><br /><a href="http://1.bp.blogspot.com/-5CpUHAoxvfg/V1xS-UQZMNI/AAAAAAAAAo8/RuXmrQXpw9E7o_9dPRa96Y1ptWLP4vryQCK4B/s1600/fpu%2Binstruction%2B1.PNG" imageanchor="1"><img border="0" height="402" src="https://1.bp.blogspot.com/-5CpUHAoxvfg/V1xS-UQZMNI/AAAAAAAAAo8/RuXmrQXpw9E7o_9dPRa96Y1ptWLP4vryQCK4B/s640/fpu%2Binstruction%2B1.PNG" width="640" /></a><br /><br />An important point to note here is that the value 0xFE8BC1A0 is the value calculated from the first 5 steps of the algorithum that we have examined so far. Moving on though, we can see that the MM7 register of the FPU stack has now been changed to hold the value 0x000000000FE8BC1A.<br /><br />The next instruction, <i>LEA ESP, [ESP+8]</i> loads the address of ESP+8, which holds the name that I entered into the program (in this case "Grant"), into ESP. This effectively moves the stack pointer so that it now points at our name on the stack.<br /><br />The instruction <i>FSTP QWORD PTR SS:[LOCAL.260] </i>pops the QWORD value  0x000000000FE8BC1A off of the FPU stack and writes it to the local variable <i>LOCAL.260</i>. If we look closer at the information provided by OllyDBG, we can see that <i>LOCAL.260</i> is the address 0x0063FB30. Following this in the dump (right click on the address in the information display and click <i>Follow in Dump</i>) shows that the memory is currently empty:<br /><br /><a href="http://4.bp.blogspot.com/-Al9OLpE0IeE/V1xXhO8BbKI/AAAAAAAAApI/1iFOxkmEIzELZeJvkNQMDVyIRf-mLLUXgCK4B/s1600/fpu%2Bstoring%2Bpointer%2Bin%2Bmemory.PNG" imageanchor="1"><img border="0" height="432" src="https://4.bp.blogspot.com/-Al9OLpE0IeE/V1xXhO8BbKI/AAAAAAAAApI/1iFOxkmEIzELZeJvkNQMDVyIRf-mLLUXgCK4B/s640/fpu%2Bstoring%2Bpointer%2Bin%2Bmemory.PNG" width="640" />&nbsp;</a><br /><br />We can also see that OllyDBG tells us that the float value 4270571936.0000000000 will be written into memory at this address. Pressing F7 to do a single step in OllyDBG, we can see that the memory has been adjusted, though not quite in the way we expected:<br /><br /><a href="http://4.bp.blogspot.com/-Bet1Chlr8Cs/V1xZco2brlI/AAAAAAAAApU/4hwrbOhl5TIzP-uPsiRxdxActAfFqc5WACK4B/s1600/floating%2Bpoint%2Binstruction%2Badjusts%2Bmemory%2Bin%2Bodd%2Bway.PNG" imageanchor="1"><img border="0" height="328" src="https://4.bp.blogspot.com/-Bet1Chlr8Cs/V1xZco2brlI/AAAAAAAAApU/4hwrbOhl5TIzP-uPsiRxdxActAfFqc5WACK4B/s640/floating%2Bpoint%2Binstruction%2Badjusts%2Bmemory%2Bin%2Bodd%2Bway.PNG" width="640" />&nbsp;</a><br /><br />Whats happened here? Well, this took me a bit of research and I had to look at some previous answers to understand what happened here, but apparently the <i>FSTP </i>instruction, when converting the number 0x000000000FE8BC1A to floating point number, or 4270571936.0, also packed the number into binary format before storing it in memory. Reversing the bytes, this means that the number is now stored as 0x41EFD17834000000 at 0x0063FB30 in memory.<br /><br />The next two instructions <i>FLD QWORD PTR SS:[LOCAL.260] </i>and <i>FSTP QWORD PTR SS:[ESP+8]</i> first load the value of <i>LOCAL.260</i>, which is now  0x41EFD17834000000, onto the FPU stack, and then POP that value off of the FPU stack and write it to ESP+8.<br /><br /><i>MOV DWORD PTR SS:[ESP+4],00401469 </i>moves the string "%i-x019871" into ESP+4, and the following two instructions <i>LEA EAX,[LOCAL.194]</i> and <i>MOV DWORD PTR SS:[ESP],EAX </i>load the address of <i>LOCAL.194</i> into EAX and push it as the first argument. We then see a call to sprintf with these three parameters. From this we can conclude that we are sprinting the resulting serial into memory at <i>LOCAL.194</i>, and that the string "%i-x019871" is the format string to print into memory, whilst <i>LOCAL.260</i> is the value that will replace the "%i" part of the format string before it is placed into memory.<br /><h3><br /></h3><h3><span style="font-size: large;"><u>Final Crackme Algorithum </u></span></h3>From this, we now have our crackme algorithum. We also know that the generated number is appended with the string "-x019871". Our new algorithum now looks as follows:<br /><ol><li>Calculates the length of the user's name.</li><li>Multiply this number by 0x875cd.</li><li>Take the result of this operation, multiply it by 0x51eb851f and take the higher 32 bits of the result.</li><li>Bit-shift this number right 5 bits, effectively dividing by 32.</li><li>Multiply the resulting value by 0xfffffc90, and store only the lower 32 bits as the result.</li><li>Take this value in hex and convert it to a floating point decimal number, then pack the result in binary format.</li><li>Convert the number back to an integer, and append the string "-x019871" to it. </li></ol><h3><span style="font-weight: normal;"></span></h3><h3><span style="font-size: large;"><span style="font-weight: normal;"><u><b>The Keygen</b></u></span></span></h3><span style="font-weight: normal;">The last part of the challenge asked one to generate a keygen for the program. This is a small program which takes the algorithum mentioned above and generates a serial based on the name entered. I will leave this as an exercise for you to complete, however if you would like to see my poorly annotated, hacky solution, you can find it here: <a href="https://drive.google.com/file/d/0B5pT4hU_yYUWMnBfVTllaHNrMWc/view?usp=sharing">https://drive.google.com/file/d/0B5pT4hU_yYUWMnBfVTllaHNrMWc/view?usp=sharing</a></span><br /><span style="font-weight: normal;"></span><br /><h3><span style="font-size: large;"><span style="font-weight: normal;"><u><b>Conclusion</b></u></span></span></h3><span style="font-weight: normal;">I hope you enjoyed this tutorial and it inspired you to get into crackmes more :) I appologise if it was overly detailed in places but I wanted to make as many people could follow along as possible. Let me know if you have any comments or feedback!</span><br /><span style="font-weight: normal;"><br /></span><span style="font-weight: normal;">-tekwizz123</span><br /><br /><br /><br /><br /><br /><br /><br />