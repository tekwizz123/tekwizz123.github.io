---
layout: post
title: 'Practical Reverse Engineering - Chapter 1 pg 35 - Exercise #5 - KeInitializeDPC
  and KeInitializeThreadedDpc'
date: '2018-12-10T23:54:00.002-08:00'
author: thetekwizz
tags: 
modified_time: '2018-12-10T23:56:34.856-08:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-2429621693903580132
blogger_orig_url: https://tekwizz123.blogspot.com/2018/12/practical-reverse-engineering-chapter-1_10.html
---

<b>Question: Decompile the following kernel routines in Windows:</b><br /><ul><li><b>KeInitializeDpc </b></li></ul><br /><u>KeInitializeDpc</u><br />So for starters lets see if there is any MSDN documentation on this function. Looking things up we see this link: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-keinitializedpc">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-keinitializedpc</a><br />So from this we can tell the function header should be the following: <br /><pre><code class="c">NTKERNELAPI VOID KeInitializeDpc(<br />    PRKDPC Dpc,<br />    PKDEFERRED_ROUTINE DeferredRoutine,<br />    PVOID DeferredContext<br />);<br /></code></pre>The corresponding disassembly of this function can be seen below:<br /><pre><code class="x86asm">; void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)<br />public KeInitializeDpc<br />KeInitializeDpc proc near<br />xor     eax, eax<br />mov     dword ptr [rcx], 113h<br />mov     [rcx+38h], rax<br />mov     [rcx+10h], rax<br />mov     [rcx+18h], rdx<br />mov     [rcx+20h], r8<br />retn<br />KeInitializeDpc endp<br /></code></pre>Looking at the definition of this function, we immediately notice that RCX appears to be some sort of structure that is getting filled out. According to x64 documentation, the first argument is passed in RCX, the second in RDX, the third in R8 and the fourth in R9<i>. </i>This would mean that RCX corresponds to <i>PRKDPC Dpc</i>.<br /><br />But what is <i>PRKDPC?</i> If we refer back again to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-keinitializedpc">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-keinitializedpc</a>, we can see this is a pointer to a <i>KDPC</i> object. Using the magic of WinDBG, we can dump the outline of this structure, even though its supposed to be an <i>opaque structure</i> (aka "we may change this structure so don't rely on the details of it remaining the same"), using the <i>dt </i>command. Specifically, <i>dt nt!_KDPC</i> will give us the details we need: <br /><pre><code class="plaintext">0:010&gt; dt nt!_KDPC<br />ntdll!_KDPC<br />   +0x000 TargetInfoAsUlong : Uint4B<br />   +0x000 Type             : UChar<br />   +0x001 Importance       : UChar<br />   +0x002 Number           : Uint2B<br />   +0x008 DpcListEntry     : _SINGLE_LIST_ENTRY<br />   +0x010 ProcessorHistory : Uint8B<br />   +0x018 DeferredRoutine  : Ptr64     void <br />   +0x020 DeferredContext  : Ptr64 Void<br />   +0x028 SystemArgument1  : Ptr64 Void<br />   +0x030 SystemArgument2  : Ptr64 Void<br />   +0x038 DpcData          : Ptr64 Void<br /></code></pre>Ok so now that we know what offsets correspond to different parts of the <i>KDPC</i> object, we can translate the x64 assembly code into the following C code: <br /><pre><code class="C">NTKERNELAPI VOID KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext){<br />  PRKDPC-&gt;TargetInfoAsUlong = 0x113;<br />  PRKDPC-&gt;DpcData = NULL;<br />  PRKDPC-&gt;ProcessorHistory = 0;<br />  PRKDPC-&gt;DeferredRoutine = DeferredRoutine;<br />  PRKDPC-&gt;DeferredContext = DeferredContext;<br />}<br /></code></pre>If we check this against the HexRays disassembly we can see this is pretty much the same output: <br /><pre><code class="C">void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)<br />{<br />  Dpc-&gt;TargetInfoAsUlong = 275;<br />  Dpc-&gt;DpcData = 0i64;<br />  Dpc-&gt;ProcessorHistory = 0i64;<br />  Dpc-&gt;DeferredRoutine = (void (__fastcall *)(_KDPC *, void *, void *, void *))DeferredRoutine;<br />  Dpc-&gt;DeferredContext = DeferredContext;<br />}<br /></code></pre>So now that is out of the way, the question remains why <i>TargetInfoAsUlong</i> is specifically set to a value of 0x113. Referring back to the<i> </i>WinDBG dump, we can see that <i>TargetInfoAsUlong</i> is actually a structure that contains a one byte <i>Type</i> field, a one byte <i>Importance</i> field, and a two byte <i>Number</i> field.<br /><br />Therefore setting the value of <i>TargetInfoAsUlong</i> to 0x113 actually sets <i>Type </i>to 0x13<i>, Importance</i> to 0x1 and <i>Number</i> to 0x0.<i> </i>To get a better idea of the <i>KDPC</i> structure I tried referring to ReactOS, specifically <a href="https://doxygen.reactos.org/d9/d82/struct__KDPC.html">https://doxygen.reactos.org/d9/d82/struct__KDPC.html</a>, however there is no documentation there on any of the fields, just the KDPC structure itself.<br /><br />So with ReactOS out of the way I ended up turning to Geoff Chappel's website, which has a TON of really cool blog posts on research he has done into the Windows kernel. Specifically he has a brilliant article on KDPC available at <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ke/dpcobj/kdpc.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ke/dpcobj/kdpc.htm</a>. From here we can learn that the value of the <i>Importance </i>field is actually <i>MediumImportance</i>, which is the default value for a KDPC object unless it is changed via <i>KeSetImportanceDpc</i>.<br /><br />This is kind of ironic as if we look at the code for <i>KeSetImportanceDpc</i> we will see what has to be the world's simplest kernel function:<br /><pre><code class="x86asm">public KeSetImportanceDpc<br />KeSetImportanceDpc proc near<br />mov     [rcx+1], dl<br />retn<br />KeSetImportanceDpc endp<br /></code></pre>Which makes sense as this is essentially just taking in a a KDPC object along with a byte value as arguments, and is then setting the<i> Importance</i> flag of the KDPC object to the byte value specified.<br /><br /><i></i>If we now turn our attention to the <i>Type</i> field we can see that Geoff Chappel notes that this field is <i>DpcObject</i> for a normal DPC or <i>ThreadedDpcObject</i> for a threaded DPC. Looking up <i>DpcObject</i> brings us to https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kobjects.htm which shows that on Windows kernel versions later than 3.51 (aka any modern OS), the value for <i>DpcObject </i>is 0x13.<br /><br />For those interested, according to Geoff Chappel <i>ThreadedDpcObject</i> is apparently 0x1A on NT 6.3 and later (aka Windows 8.1 and later), however its value from NT 5.2 to 6.2 (Windows XP to Windows 8) was 0x18). This can be confirmed if I decompile the function <i>KeInitializeThreadedDpc </i>on a Windows 10 build:<br /><pre><code class="x86asm">KeInitializeThreadedDpc proc near<br />xor     eax, eax<br />mov     dword ptr [rcx], 11Ah<br />mov     [rcx+38h], rax<br />mov     [rcx+10h], rax<br />mov     [rcx+18h], rdx<br />mov     [rcx+20h], r8<br />retn<br />KeInitializeThreadedDpc endp<br /></code></pre>Again this is pretty much the same code as before, the only difference is that this time the<i> Type</i> value is being set 0x1A, or <i>ThreadedDpcObject</i>. Otherwise the code is exactly the same as <i>KeInitializeDpc</i>.<br /><br /><i></i> Finally Geoff Chappel notes that the <i>Number</i> field denotes the importance or the processor on which this DPC will be run. I assume given that this is set to 0 that the idea is its either being either set to its initial priority or its being set to run on processor 0. With this knowledge we can create a better decompiled version of both <i>KeInitializeDpc</i> and <i>KeInitializeThreadedDpc</i>:<br /><pre><code class="C">void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)<br />{<br />  PRKDPC-&gt;Type = DpcObject;<br />  PRKDPC-&gt;Importance = MediumImportance;<br />  PRKDPC-&gt;Number = 0;<br />  PRKDPC-&gt;DpcData = NULL;<br />  PRKDPC-&gt;ProcessorHistory = 0;<br />  PRKDPC-&gt;DeferredRoutine = DeferredRoutine;<br />  PRKDPC-&gt;DeferredContext = DeferredContext;<br />}<br /><br />void __stdcall KeInitializeThreadedDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)<br />{<br />  PRKDPC-&gt;Type = ThreadedDpcObject;<br />  PRKDPC-&gt;Importance = MediumImportance;<br />  PRKDPC-&gt;Number = 0;<br />  PRKDPC-&gt;DpcData = NULL;<br />  PRKDPC-&gt;ProcessorHistory = 0;<br />  PRKDPC-&gt;DeferredRoutine = DeferredRoutine;<br />  PRKDPC-&gt;DeferredContext = DeferredContext;<br />}<br /></code></pre>Hope you enjoyed this walkthrough. If you have any questions, comments, or otherwise feel free to drop them down below. I'm still very new to Windows kernel reversing so its quite possible I've stuffed something up, though I'm open to suggestions and improvements so please do send them my way.<br /><br />More kernel function reversing entries will be coming soon, although they may be separate entries as some of these are a bit longer than I originally expected with the extra background research I'm doing for them. 