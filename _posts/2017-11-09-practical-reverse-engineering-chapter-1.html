---
layout: post
title: Practical Reverse Engineering - Chapter 1 pg 11 Exercise 1
date: '2017-11-09T06:39:00.003-08:00'
author: thetekwizz
tags: 
modified_time: '2018-12-09T17:48:01.955-08:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-6585024394577884540
blogger_orig_url: https://tekwizz123.blogspot.com/2017/11/practical-reverse-engineering-chapter-1.html
---

<h2><u>Problem</u></h2><div>"This function uses a combination of SCAS and STOS to do its work. First, explain what is the type of the [EBP+8] and [EBP+C] in line 1 and 8 respectively. Next explain what this snippet does."</div><div><br /></div><h3>Disassembly:</h3><pre><br /><code class="x86asm">1   mov edi, [ebp+8]<br />2   mov edx, edi<br />3   xor eax, eax<br />4   or ecx, 0FFFFFFFFh<br />5   repne scasb<br />6   add ecx, 2<br />7   neg ecx<br />8   mov al, [ebp+0xC]<br />9   mov edi, edx<br />10  rep stosb<br />11  mov eax, edx<br /></code></pre><h3>Explanation:</h3><pre><br /><code class="plaintext">Line 1: We set EDI to be the value at EBP+8<br /><br />Line 2: We save the value of EBP+8 to EDX.<br /><br />Line 3: Clear out EAX, aka set EAX to 0.<br /><br />Line 4: Set ECX to 0xFFFFFFFF or -1 by OR'ing all of <br />        its bytes with 0xFFFFFFFF. As 0x1 OR 0x1 = 1, <br />        and 0x1 OR 0x1 = 1, all bits will be set, <br />        making it -1.<br /><br />Line 5: Read value held in EDI, aka the value pointed<br />        to by EBP+8, and check if it is the same as EAX, <br />        or 0. When we look at the REPNE instruction, we<br />        can see this is essentially a strlen operation <br />        as we will keep repeating this operation and <br />        decrementing ECX by 1 each time until we hit <br />        a NULL byte terminator aka 0.<br /><br />Line 6: Add 2 to ECX. If we performed the STOSB <br />        instruction 8 times, the value in ECX would <br />        be -9. Adding 2 to this value will make it -7, <br />        aka the negative equivalent of the number of <br />        characters in the string before the null byte.<br /><br />Line 7: Use the NEG ECX instruction to do a 2's compliment<br />        operation on ECX and in effect flip the sign bit <br />        of ECX, transforming it from a negative number to a<br />        positive one. In our example, ECX would go from -7 to 7.<br /><br />Line 8: Move byte held at EBP+0xC into AL.<br /><br />Line 9: Set EDI back to the address pointed to by EBP+8 <br />        using EDX, where we had saved the original EBP+8 value.<br /><br />Line 10: For ECX times, aka the number of characters in the <br />         string as determined earlier, write the byte <br />         contained at EBP+0xC, aka AL, into the string <br />         array pointed to by EBP+8, aka EDI.<br /><br />Line 11: Move EDX, aka the start of the string buffer<br />         or EBP+8, into EAX so we can return it to <br />         the calling function.<br /></code></pre>So in essence this could be simplified down to the following in C: <pre><br /><code class="c">int len = strlen(*(EBP+8));<br />memset(*(EBP+8), (BYTE *)(EBP+0xC), len);<br /></code></pre>We also can answer the other question as we now know that [EBP+0xC] is a pointer to a byte value to use for the memset operation, and [EBP+8] is a pointer to a NULL terminated string which we want to memset to the value pointed to by [EBP+0xC].<br /> <br />Hope that helps!<br /><br />-tekwizz123 