---
layout: post
title: Practical Reverse Engineering - Chapter 1 pg 25 - Author's Challenge Solution
date: '2018-11-12T21:56:00.000-08:00'
author: thetekwizz
tags: 
modified_time: '2018-12-09T18:06:47.721-08:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-5696310604944019718
blogger_orig_url: https://tekwizz123.blogspot.com/2018/11/practical-reverse-engineering-chapter-1.html
---

<h4><b>Question: Take the example shown on page 24 and decompile it further to make it look more "natural"</b></h4><br /><h4>Solution:</h4><pre><code class="c">char * sub_1000AE3B(char * aStr){<br />    signed int length = lstrlenA(aStr);<br />    signed int counter1 = 0;<br />    signed int counter2 = 0;<br />    if(length != 0){<br />        while(counter2 &lt; length){<br />            aStr[counter1] = aStr[counter2];<br />            counter2 += 3;<br />            counter1 += 1;<br />        }<br />    }<br />    aStr[counter1] = '\x00';<br />    return aStr;<br />}<br /></code></pre><h4>Additional Notes</h4>The disassembly on page 25 of the edition I am reading is incorrect. In the example given the authors provide an example whose assembly is as follows:<br /><pre><code class="x86asm">01 mov ecx, edx<br />02 loc_CFB8F:<br />03     lodsd<br />04     not eax<br />05     stosd<br />06     loop loc_CFB8F<br /></code></pre>They then state that this is the corresponding disassembly<i> </i>to C: <br /><pre><code class="C">while (ecx != 0) {<br />     eax = *edi<br />     edi++;<br />     *esi = ~eax;<br />      esi++;<br />      ecx--;<br />}<br /></code></pre>If one refers back to their earlier remarks about how <i>lodsd</i> works, one will see that this command actually loads into EAX the DWORD at the location pointed to by ESI (refer to&nbsp;<a href="http://faydoc.tripod.com/cpu/lodsd.htm">http://faydoc.tripod.com/cpu/lodsd.htm</a><i> </i>or the x86 instruction manual by Intel if you need further confirmation). Similarly, <i>stosd</i> actually stores the value at EAX into EDI, not ESI as shown above (see&nbsp;<a href="http://faydoc.tripod.com/cpu/stosd.htm">http://faydoc.tripod.com/cpu/stosd.htm</a>).<br /><i> </i><br />Therefore the rough C code should actually be: <pre><br /><code class="C">while (ecx != 0) {<br />     eax = *esi<br />     esi++;<br />     *edi = ~eax;<br />      edi++;<br />      ecx--;<br />}<br /></code></pre>Aka a simple switch of the ESI and EDI registers in the example C code provided.