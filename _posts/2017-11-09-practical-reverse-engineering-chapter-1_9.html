---
layout: post
title: 'Practical Reverse Engineering - Chapter 1 pg 17 Exercise '
date: '2017-11-09T09:04:00.003-08:00'
author: thetekwizz
tags: 
modified_time: '2018-12-10T20:50:42.686-08:00'
blogger_id: tag:blogger.com,1999:blog-1094392735627525300.post-3331665925114493625
blogger_orig_url: https://tekwizz123.blogspot.com/2017/11/practical-reverse-engineering-chapter-1_9.html
---

<h3>Question 1</h3><div><br /><b>Question: Given what you learned about CALL and RET, explain how you would read the value of EIP? Why can't you just do MOV EAX, EIP?</b></div><div><br /></div><div>Answer: The easiest way I could think of to read the current value of EIP was to do the following:</div><div><br /></div><div>CALL *instruction after this call instruction* &lt;- 5 Bytes</div><div>POP EAX &lt;- 1 Byte (the instruction that we will point to)</div><div>ADD EAX, 4 &lt;- 3 bytes</div><div><br /></div><div>Essentially we will do a CALL to the POP EAX instruction, at which point ESP will point to the address where "POP EAX" is located in memory (aka the return address for the CALL instruction). POP EAX will ensure EAX gets set to this value. Adding 4 to EAX will ensure we add 1 to this value to compensate for the "POP EAX" instruction, then we add another 3 for the bytes that formulate the "ADD EAX, 4" instruction.</div><div><br /></div><div>And there we go, we have EIP :)</div><div><br /></div><div>To answer the other question we can refer to page 82 of&nbsp;<a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf</a>&nbsp;or section 3.5 of volume 1 of the Intel Software Developer's Manual. On this page they mention that EIP can only be controlled by control transfer instructions like CALL, JMP, etc. It cannot be directly accessed by software in x86.</div><div><br /><h3>Question 2</h3></div><div><br /><b>Question: Come up with at least two code sequences to set EIP to 0xAABBCCDD.</b></div><div><br /></div><div>Answer:</div><div><br /></div><div><u>Option 1</u></div><div>PUSH 0xAABBCCDD ; PUSH value onto the stack</div><div>RETN ; POP the value at the top of the stack into EIP and resume execution from this location.</div><div><br /></div><div><u>Option 2</u></div><div>JMP 0xAABBCCDD ; Just straight up redirect execution. Why not make it simple after all?<br /><br /><u>Option 3</u><br />CALL 0xAABBCCDD ; Another option :)<br /><br /><u>Option 4 - Aka the fancier conditional option</u><br />XOR EAX, EAX ; Set EAX to zero<br />TEST EAX, EAX ; Check if EAX is 0<br />JZ 0xAABBCCDD ; Jump to 0xAABBCCDD if so.</div><div><br /><h3>Question 3</h3></div><div><br /><b>Question: In the example function, <i>addme</i>, what would happen if the stack pointer were not properly restored before executing RET?</b></div><div><br /></div><div>Answer: Well considering the stack pointer would be the part where we do the <i>PUSH EBP</i>&nbsp;instruction, we would return execution to EBP, which means we would return execution to the base pointer of the function that called the <i>addme()</i> function. Since this base pointer will be an address on the stack, this will result in the program trying to execute data off of the stack itself as though it was code. What happens from here depends on the data that is on the stack, but most likely some invalid instructions would be executed and the program would crash. This is assuming the stack is executable as on modern systems the more likely scenario is that DEP would kick in and you would get an ACCESS VIOLATION as the stack would be marked as non-executable.</div><div><br /><h3>Question 4</h3></div><div><br /><b>Question: In all of the calling conventions explained the return value is stored in a 32-bit register (EAX). What happens when the return value does not fit in a 32-bit register? Write a program to experiment and evaluate your answer. Does the mechanism change from compiler to compiler?</b></div><div><br /></div><div>Answer: So the answer to this, according to my testing it depends how the program is written<span style="color: black;"><span style="color: black;"></span></span>. For a test I wrote the following program: <pre><code class="c">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main(int argc, char *argv[]) {<br /> long long num = 0x8888888822223344;<br /> return num;<br />}<br /></code></pre>The output of this when compiled with Dev C++ 5.11 with the TDM-GCC 4.9.2 32 Bit Release option and then decompiled with IDA Pro was as follows: <br /><pre><br /><code class="x86asm">; int __cdecl main(int argc, const char **argv, const char **envp)<br />public _main<br />_main proc near<br /><br />argc= dword ptr 8<br />argv= dword ptr 0Ch<br />envp= dword ptr 10h<br /><br />push ebp<br />mov ebp, esp<br />and esp, 0FFFFFFF0h<br />sub esp, 10h<br />call ___main<br />mov dword ptr [esp+8], 22223344h<br />mov dword ptr [esp+0Ch], 88888888h<br />mov eax, [esp+8]<br />leave<br />retn<br />_main endp<br /></code></pre>As can be seen in this solution, GCC has attempted to try and save a 64 bit number by using the stack to store the upper 32 bits of the number at [ESP+0xC] and the lower 32 bits of the number at [ESP+0x8]. However it only returns the lower 32 bits of the number as EAX is set to the value of [ESP+0x8], which will just contain the lower 32 bits of 0x8888888822223344, aka 0x22223344.<br /><br />Now for the interesting bit. So what if one sets the return value directly then? Well we get the following compilation warning: <pre><code class="plaintext">[Warning] overflow in implicit constant conversion [-Woverflow]</code></pre>Here is the program: <pre><br /><code class="c">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main(int argc, char *argv[]) {<br />    return 0x8888888822223344;<br />}<br /></code></pre>And here is the corresponding assembly: <br /><pre><br /><code class="x86asm">; int __cdecl main(int argc, const char **argv, const char **envp)<br />public _main<br />_main proc near<br /><br />argc= dword ptr  8<br />argv= dword ptr  0Ch<br />envp= dword ptr  10h<br /><br />push    ebp<br />mov     ebp, esp<br />and     esp, 0FFFFFFF0h<br />call    ___main<br />mov     eax, 22223344h<br />leave<br />retn<br />_main endp<br /></code></pre>Looks like our number got truncated again, but unlike last time no attempt was made to actually try to save the upper 32 bits of the number specified as the return address anywhere. The compiler instead decided to optimize things and just drop the upper 32 bits entirely, thereby only utilizing the lower 32 bits, aka 0x22223344, in its operations.<br /><br />Finally, lets try Visual Studio 2017 Community. Upon compilation of the first example we get the following warning: <pre><code class="plaintext">c:\users\*redacted*\consoleapplication2\consoleapplication2.cpp(10): warning C4244: 'return': conversion from '__int64' to 'int', possible loss of data</code></pre>Looks to be a fairly accurate description of what might happen here :) But lets just check the disassembly to be sure: <pre><br /><code class="x86asm">; int __cdecl main_0(int argc, const char **argv, const char **envp)<br />_main_0 proc near<br /><br />var_D0= byte ptr -0D0h<br />var_C= dword ptr -0Ch<br />var_8= dword ptr -8<br />argc= dword ptr  8<br />argv= dword ptr  0Ch<br />envp= dword ptr  10h<br /><br />push    ebp<br />mov     ebp, esp<br />sub     esp, 0D0h<br />push    ebx<br />push    esi<br />push    edi<br />lea     edi, [ebp+var_D0]<br />mov     ecx, 34h<br />mov     eax, 0CCCCCCCCh<br />rep stosd<br />mov     [ebp+var_C], 22223344h<br />mov     [ebp+var_8], 88888888h<br />mov     eax, [ebp+var_C]<br />pop     edi<br />pop     esi<br />pop     ebx<br />mov     esp, ebp<br />pop     ebp<br />retn<br />_main_0 endp<br /></code></pre>Yep looks looks like the error message was correct, the return value is being truncated to just its first 32 bits before being returned to the caller. </div>